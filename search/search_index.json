{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"cmds/","text":"This is the first paragraph of the document.","title":"My Document"},{"location":"cmds/advanced/","text":"This is the first paragraph of the document.","title":"My Document"},{"location":"cmds/common/alias/","text":"This is the first paragraph of the document.","title":"alias"},{"location":"cmds/common/cat/","text":"This is the first paragraph of the document.","title":"cat"},{"location":"cmds/common/cd/","text":"This is the first paragraph of the document.","title":"cd"},{"location":"cmds/common/clear/","text":"This is the first paragraph of the document.","title":"clear"},{"location":"cmds/common/cp/","text":"This is the first paragraph of the document.","title":"cp"},{"location":"cmds/common/date/","text":"This is the first paragraph of the document.","title":"date"},{"location":"cmds/common/echo/","text":"This is the first paragraph of the document.","title":"echo"},{"location":"cmds/common/grep/","text":"This is the first paragraph of the document.","title":"grep"},{"location":"cmds/common/head/","text":"This is the first paragraph of the document.","title":"head"},{"location":"cmds/common/history/","text":"This is the first paragraph of the document.","title":"history"},{"location":"cmds/common/kill/","text":"This is the first paragraph of the document.","title":"kill"},{"location":"cmds/common/killall/","text":"This is the first paragraph of the document.","title":"killall"},{"location":"cmds/common/less/","text":"This is the first paragraph of the document.","title":"less"},{"location":"cmds/common/ls/","text":"This is the first paragraph of the document.","title":"ls"},{"location":"cmds/common/man/","text":"This is the first paragraph of the document.","title":"man"},{"location":"cmds/common/mkdir/","text":"This is the first paragraph of the document.","title":"mkdir"},{"location":"cmds/common/more/","text":"This is the first paragraph of the document.","title":"more"},{"location":"cmds/common/mv/","text":"This is the first paragraph of the document.","title":"mv"},{"location":"cmds/common/pwd/","text":"This is the first paragraph of the document.","title":"pwd"},{"location":"cmds/common/rm/","text":"This is the first paragraph of the document.","title":"rm"},{"location":"cmds/common/rmdir/","text":"This is the first paragraph of the document.","title":"rmdir"},{"location":"cmds/common/tail/","text":"This is the first paragraph of the document.","title":"tail"},{"location":"cmds/common/touch/","text":"This is the first paragraph of the document.","title":"touch"},{"location":"fs/","text":"This is the first paragraph of the document.","title":"Filesystem"},{"location":"shell/shell/","text":"Unix shell is a command-line interpreter or shell that provides a command line user interface for Unix-like operating systems. The shell is both an interactive command language and a scripting language, and is used by the operating system to control the execution of the system using shell scripts. Shell Operation Variables $PATH Alias Exit Status Pipes and Redirections Lists of Commands Tab Completions Shell Scripts Shell Operation The following is a brief description of the shell\u2019s operation when it reads and executes a command. Basically, the shell does the following: Reads its input from a file (see Shell Scripts ) or from the user\u2019s terminal. Breaks the input into words and operators. These tokens are separated by metacharacters. Alias expansion is performed by this step (see Alias ). Parses the tokens into simple and compound commands. Performs the various shell expansions, breaking the expanded tokens into lists of filenames and commands and arguments. Performs any necessary redirections (see Pipes and Redirections ) and removes the redirection operators and their operands from the argument list. Executes the command. Optionally waits for the command to complete and collects its exit status (see Exit Status). Variables As in any other programming language, the shell has variables, these variables do not have any datatype as they can store a number, a character, a string of characters or lists. All variables are global to the current shell session (but not to a sub-process) The standard practice is that variables are always in uppercase, but there is no technical reason why they can\u2019t be in lowercase. To create a variable name it, and assign a value to it MY_VAR = \"hello\" To access a variable, add the $ prefix to the name of the variable echo $MY_VAR The shell can also, expand variables within strings created by double-quotes \" echo \"The value of MY_VAR is $MY_VAR \" Using export in front of a variable makes the variable available to sub-processes. This variables, also call Environment Variables export JAVA_HOME = /opt/java Variables are always expanded before running the command (step 4, of Shell Operation) Shells like bash, zsh, and fish will run scripts on there initialization that populate variables, this scripts can for all users, and each user can define it\u2019s own (.bashrc or .bash_profile for bash, .zshrc for zsh) in user\u2019s home dirrectory. These variables will be always present in the shell session. Examples of these variables are: USER, current user name HOSTNAME, name of the machine SHELL, current shell PATH, list of directories where the shell will look up for commands. $PATH The $PATH variable is one of the most important variable in a shell session, since it\u2019s a list of directories where the shell will look for executables (binaries, or scripts). The shell will always use the first binary found, so a user can override this variable to change which binary will be used. This change can done to a current shell session or make it permanent by adding the override in the shell initialization script. export PATH = /my/bin/location: $PATH Alias An alias is a keyboard shortcut, an abbreviation to avoiding typing a long command sequence alias la = ls -alh The command-line will automatically be replaced by la with ls -alh Aliases can be set by shell session or, permanent by adding them in the shell initialization script. Aliases can be named same as commands, this aliases will take priority over the actual command regardless of its position in the $PATH variable this is useful when, we want to add default arguments and options to the command, for example alias grep = 'grep --color' List of common and useful aliases. # Search Through Terminal History alias hs = 'history | grep' #Open file with admin access alias snano = 'sudo nano' #clear terminal screen alias c = 'clear' # Shows all open ports alias ports = 'netstat -tulanp' #Tail a file alias t = 'tail -f' Exit Status The Portable Operating System Interface (POSIX) defines that all process should have an exit code. Exit codes are a number between 0 and 255, which is returned by any Unix command when it returns control to its parent process. 0 always means that the command was run successfully, any other number, will be interpreted as an error by the shell. Most POSIX compliant shells will store the Exit code in a variable named $? ls echo $? ls IdontExist echo $? The first echo $? will return 0 , since ls run without any issue, The following echo $? will return 2 since, ls was not run successfully, since, IdontExist well, does not exists. Pipes and Redirections Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface. \u2014 Peter H. Salus. A Quarter-Century of Unix. Addison-Wesley. 1994. ISBN 0-201-54777-5. Commands can send and receive output from other commands using pipelines and redirections. They both do the same basic thing; they redirect a file descriptor of the process executed. Pipe is used to pass output to another program or utility. Redirect is used to pass output to either a file or stream. A pipeline is a sequence of one or more commands separated by one of the control operators \u2018|\u2019 or \u2018|&\u2019. The output of each command in the pipeline is connected via a pipe to the input of the next command. That is, each command reads the previous command\u2019s output. ls | head -3 In the example above we send the output of ls to head -3 so we only print the first 3 results of ls A pipe connects the stdout of one process to the stdin of another. Redirection allows commands\u2019 file handles to be duplicated, opened, closed, made to refer to different files, and can change the files the command reads from and writes to. At any given time there are always three default files descriptors open, stdin (the keyboard), stdout (the screen), and stderr (error messages output to the screen). The file descriptors for stdin , stdout , and stderr are 0 , 1 , and 2 , respectively. > ( > is the same as 1> ) is the simplest redirection, this will redirect all stdout to a given file. ls > results.txt This will redirect the output of ls to a file named results.txt We can also \u201cmerge\u201d two file descriptors to point to the same file, this is useful when we want to have the output of stdout and stderr in the same file. To point them to the same file descriptor we use 2>&1 ( same as &>) That means that the output of 2 ( stderr ) should be redirected to 1 ( stdout ). ls 2 > & 1 > output.txt In this sequence, we tell the shell that we want the output of stderr (2) to be redirected to stdout (1) and the second > will send the output of stdout (now merge with stderr ) to a file name output.txt Redirrections will delete any information at there destination before writing anything, to avoid that the >> redirect should be used, when used, it will append the new output at the end of the destination. It is also possible to redirect stdin of a command by using < this will read the given file descriptor and send it to the command stdin . cat < myFile.txt By default cat will listen to stdin until the EOF character (ctrl-d) is sent. In the past example, change stdin to be a file. Lists of Commands It\u2019s possible to run multiple commands as a single line making a list of commands to be run, the list is made by using ; between the commands that we want to run. command1 ; command2 ; command 3 | command3.1 > myoutput.txt ; command 4 It\u2019s also possible to run the next command depending on the exit value by using && (AND) or || (OR) command1 && command2 command2 is executed if, and only if, command1 returns an exit status of zero (success). command1 || command2 command2 is executed if, and only if, command1 returns a non-zero exit status. The return status of AND and OR lists is the exit status of the last command executed in the list \u2018&&\u2019 and \u2018||\u2019 have equal precedence, followed by \u2018;\u2019 and \u2018&\u2019, which have equal precedence Tab Completions Shell Scripts","title":"Shell"},{"location":"shell/shell/#shell-operation","text":"The following is a brief description of the shell\u2019s operation when it reads and executes a command. Basically, the shell does the following: Reads its input from a file (see Shell Scripts ) or from the user\u2019s terminal. Breaks the input into words and operators. These tokens are separated by metacharacters. Alias expansion is performed by this step (see Alias ). Parses the tokens into simple and compound commands. Performs the various shell expansions, breaking the expanded tokens into lists of filenames and commands and arguments. Performs any necessary redirections (see Pipes and Redirections ) and removes the redirection operators and their operands from the argument list. Executes the command. Optionally waits for the command to complete and collects its exit status (see Exit Status).","title":"Shell Operation"},{"location":"shell/shell/#variables","text":"As in any other programming language, the shell has variables, these variables do not have any datatype as they can store a number, a character, a string of characters or lists. All variables are global to the current shell session (but not to a sub-process) The standard practice is that variables are always in uppercase, but there is no technical reason why they can\u2019t be in lowercase. To create a variable name it, and assign a value to it MY_VAR = \"hello\" To access a variable, add the $ prefix to the name of the variable echo $MY_VAR The shell can also, expand variables within strings created by double-quotes \" echo \"The value of MY_VAR is $MY_VAR \" Using export in front of a variable makes the variable available to sub-processes. This variables, also call Environment Variables export JAVA_HOME = /opt/java Variables are always expanded before running the command (step 4, of Shell Operation) Shells like bash, zsh, and fish will run scripts on there initialization that populate variables, this scripts can for all users, and each user can define it\u2019s own (.bashrc or .bash_profile for bash, .zshrc for zsh) in user\u2019s home dirrectory. These variables will be always present in the shell session. Examples of these variables are: USER, current user name HOSTNAME, name of the machine SHELL, current shell PATH, list of directories where the shell will look up for commands.","title":"Variables"},{"location":"shell/shell/#path","text":"The $PATH variable is one of the most important variable in a shell session, since it\u2019s a list of directories where the shell will look for executables (binaries, or scripts). The shell will always use the first binary found, so a user can override this variable to change which binary will be used. This change can done to a current shell session or make it permanent by adding the override in the shell initialization script. export PATH = /my/bin/location: $PATH","title":"$PATH"},{"location":"shell/shell/#alias","text":"An alias is a keyboard shortcut, an abbreviation to avoiding typing a long command sequence alias la = ls -alh The command-line will automatically be replaced by la with ls -alh Aliases can be set by shell session or, permanent by adding them in the shell initialization script. Aliases can be named same as commands, this aliases will take priority over the actual command regardless of its position in the $PATH variable this is useful when, we want to add default arguments and options to the command, for example alias grep = 'grep --color' List of common and useful aliases. # Search Through Terminal History alias hs = 'history | grep' #Open file with admin access alias snano = 'sudo nano' #clear terminal screen alias c = 'clear' # Shows all open ports alias ports = 'netstat -tulanp' #Tail a file alias t = 'tail -f'","title":"Alias"},{"location":"shell/shell/#exit-status","text":"The Portable Operating System Interface (POSIX) defines that all process should have an exit code. Exit codes are a number between 0 and 255, which is returned by any Unix command when it returns control to its parent process. 0 always means that the command was run successfully, any other number, will be interpreted as an error by the shell. Most POSIX compliant shells will store the Exit code in a variable named $? ls echo $? ls IdontExist echo $? The first echo $? will return 0 , since ls run without any issue, The following echo $? will return 2 since, ls was not run successfully, since, IdontExist well, does not exists.","title":"Exit Status"},{"location":"shell/shell/#pipes-and-redirections","text":"Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface. \u2014 Peter H. Salus. A Quarter-Century of Unix. Addison-Wesley. 1994. ISBN 0-201-54777-5. Commands can send and receive output from other commands using pipelines and redirections. They both do the same basic thing; they redirect a file descriptor of the process executed. Pipe is used to pass output to another program or utility. Redirect is used to pass output to either a file or stream. A pipeline is a sequence of one or more commands separated by one of the control operators \u2018|\u2019 or \u2018|&\u2019. The output of each command in the pipeline is connected via a pipe to the input of the next command. That is, each command reads the previous command\u2019s output. ls | head -3 In the example above we send the output of ls to head -3 so we only print the first 3 results of ls A pipe connects the stdout of one process to the stdin of another. Redirection allows commands\u2019 file handles to be duplicated, opened, closed, made to refer to different files, and can change the files the command reads from and writes to. At any given time there are always three default files descriptors open, stdin (the keyboard), stdout (the screen), and stderr (error messages output to the screen). The file descriptors for stdin , stdout , and stderr are 0 , 1 , and 2 , respectively. > ( > is the same as 1> ) is the simplest redirection, this will redirect all stdout to a given file. ls > results.txt This will redirect the output of ls to a file named results.txt We can also \u201cmerge\u201d two file descriptors to point to the same file, this is useful when we want to have the output of stdout and stderr in the same file. To point them to the same file descriptor we use 2>&1 ( same as &>) That means that the output of 2 ( stderr ) should be redirected to 1 ( stdout ). ls 2 > & 1 > output.txt In this sequence, we tell the shell that we want the output of stderr (2) to be redirected to stdout (1) and the second > will send the output of stdout (now merge with stderr ) to a file name output.txt Redirrections will delete any information at there destination before writing anything, to avoid that the >> redirect should be used, when used, it will append the new output at the end of the destination. It is also possible to redirect stdin of a command by using < this will read the given file descriptor and send it to the command stdin . cat < myFile.txt By default cat will listen to stdin until the EOF character (ctrl-d) is sent. In the past example, change stdin to be a file.","title":"Pipes and Redirections"},{"location":"shell/shell/#lists-of-commands","text":"It\u2019s possible to run multiple commands as a single line making a list of commands to be run, the list is made by using ; between the commands that we want to run. command1 ; command2 ; command 3 | command3.1 > myoutput.txt ; command 4 It\u2019s also possible to run the next command depending on the exit value by using && (AND) or || (OR) command1 && command2 command2 is executed if, and only if, command1 returns an exit status of zero (success). command1 || command2 command2 is executed if, and only if, command1 returns a non-zero exit status. The return status of AND and OR lists is the exit status of the last command executed in the list \u2018&&\u2019 and \u2018||\u2019 have equal precedence, followed by \u2018;\u2019 and \u2018&\u2019, which have equal precedence","title":"Lists of Commands"},{"location":"shell/shell/#tab-completions","text":"","title":"Tab Completions"},{"location":"shell/shell/#shell-scripts","text":"","title":"Shell Scripts"}]}