{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"specimen/","text":"Specimen Body copy Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras arcu libero, mollis sed massa vel, ornare viverra ex . Mauris a ullamcorper lacus. Nullam urna elit, malesuada eget finibus ut, ullamcorper ac tortor. Vestibulum sodales pulvinar nisl, pharetra aliquet est. Quisque volutpat erat ac nisi accumsan tempor. Sed suscipit , orci non pretium pretium, quam mi gravida metus, vel venenatis justo est condimentum diam. Maecenas non ornare justo. Nam a ipsum eros. Nulla aliquam orci sit amet nisl posuere malesuada. Proin aliquet nulla velit, quis ultricies orci feugiat et. Ut tincidunt sollicitudin tincidunt. Aenean ullamcorper sit amet nulla at interdum. Headings The 3rd level The 4th level The 5th level The 6th level Headings with secondary text The 3rd level with secondary text The 4th level with secondary text The 5th level with secondary text The 6th level with secondary text Blockquotes Morbi eget dapibus felis. Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a. Nam vehicula nunc mauris, a ultricies libero efficitur sed. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Sed molestie imperdiet consectetur. Blockquote nesting Sed aliquet , neque at rutrum mollis, neque nisi tincidunt nibh, vitae faucibus lacus nunc at lacus. Nunc scelerisque, quam id cursus sodales, lorem libero fermentum urna, ut efficitur elit ligula et nunc. Mauris dictum mi lacus, sit amet pellentesque urna vehicula fringilla. Ut sit amet placerat ante. Proin sed elementum nulla. Nunc vitae sem odio. Suspendisse ac eros arcu. Vivamus orci erat, volutpat a tempor et, rutrum. eu odio. Suspendisse rutrum facilisis risus , eu posuere neque commodo a. Interdum et malesuada fames ac ante ipsum primis in faucibus. Sed nec leo bibendum, sodales mauris ut, tincidunt massa. Other content blocks Vestibulum vitae orci quis ante viverra ultricies ut eget turpis. Sed eu lectus dapibus, eleifend nulla varius, lobortis turpis. In ac hendrerit nisl, sit amet laoreet nibh. js hl_lines=\"8\" var _extends = function(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { target[key] = source[key]; } } return target; }; Praesent at :::js return target , sodales nibh vel, tempor felis. Fusce vel lacinia lacus. Suspendisse rhoncus nunc non nisi iaculis ultrices. Donec consectetur mauris non neque imperdiet, eget volutpat libero. Lists Unordered lists Sed sagittis eleifend rutrum. Donec vitae suscipit est. Nullam tempus tellus non sem sollicitudin, quis rutrum leo facilisis. Nulla tempor lobortis orci, at elementum urna sodales vitae. In in vehicula nulla, quis ornare libero. Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis. Nam vulputate tincidunt fringilla. Nullam dignissim ultrices urna non auctor. Aliquam metus eros, pretium sed nulla venenatis, faucibus auctor ex. Proin ut eros sed sapien ullamcorper consequat. Nunc ligula ante, fringilla at aliquam ac, aliquet sed mauris. Nulla et rhoncus turpis. Mauris ultricies elementum leo. Duis efficitur accumsan nibh eu mattis. Vivamus tempus velit eros, porttitor placerat nibh lacinia sed. Aenean in finibus diam. Ordered lists Integer vehicula feugiat magna, a mollis tellus. Nam mollis ex ante, quis elementum eros tempor rutrum. Aenean efficitur lobortis lacinia. Nulla consectetur feugiat sodales. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Aliquam ornare feugiat quam et egestas. Nunc id erat et quam pellentesque lacinia eu vel odio. Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a. Nam vehicula nunc mauris, a ultricies libero efficitur sed. Mauris dictum mi lacus Ut sit amet placerat ante Suspendisse ac eros arcu Morbi eget dapibus felis. Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a. Sed aliquet, neque at rutrum mollis, neque nisi tincidunt nibh. Pellentesque eget :::js var _extends ornare tellus, ut gravida mi. js hl_lines=\"1\" var _extends = function(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { target[key] = source[key]; } } return target; }; Vivamus id mi enim. Integer id turpis sapien. Ut condimentum lobortis sagittis. Aliquam purus tellus, faucibus eget urna at, iaculis venenatis nulla. Vivamus a pharetra leo. Definition lists Lorem ipsum dolor sit amet : Sed sagittis eleifend rutrum. Donec vitae suscipit est. Nullam tempus tellus non sem sollicitudin, quis rutrum leo facilisis. Nulla tempor lobortis orci, at elementum urna sodales vitae. In in vehicula nulla. Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis. Nam vulputate tincidunt fringilla. Nullam dignissim ultrices urna non auctor. Cras arcu libero : Aliquam metus eros, pretium sed nulla venenatis, faucibus auctor ex. Proin ut eros sed sapien ullamcorper consequat. Nunc ligula ante, fringilla at aliquam ac, aliquet sed mauris. Code blocks Inline Morbi eget dapibus felis . Vivamus venenatis porttitor tortor sit amet rutrum. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque aliquet quam enim , eu volutpat urna rutrum a. Nam vehicula nunc :::js return target mauris, a ultricies libero efficitur sed. Sed molestie imperdiet consectetur. Vivamus a pharetra leo. Pellentesque eget ornare tellus, ut gravida mi. Fusce vel lacinia lacus. Listing 1 2 3 4 5 6 7 8 9 var _extends = function ( target ) { for ( var i = 1 ; i < arguments . length ; i ++ ) { var source = arguments [ i ]; for ( var key in source ) { target [ key ] = source [ key ]; } } return target ; }; Horizontal rules Aenean in finibus diam. Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis. Nam vulputate tincidunt fringilla. Nullam dignissim ultrices urna non auctor. Integer vehicula feugiat magna, a mollis tellus. Nam mollis ex ante, quis elementum eros tempor rutrum. Aenean efficitur lobortis lacinia. Nulla consectetur feugiat sodales. Data tables Sollicitudo / Pellentesi consectetur adipiscing elit arcu sed Vivamus a pharetra yes yes yes yes yes Ornare viverra ex yes yes yes yes yes Mauris a ullamcorper yes yes partial yes yes Nullam urna elit yes yes yes yes yes Malesuada eget finibus yes yes yes yes yes Ullamcorper yes yes yes yes yes Vestibulum sodales yes - yes - yes Pulvinar nisl yes yes yes - - Pharetra aliquet est yes yes yes yes yes Sed suscipit yes yes yes yes yes Orci non pretium yes partial - - - Sed sagittis eleifend rutrum. Donec vitae suscipit est. Nullam tempus tellus non sem sollicitudin, quis rutrum leo facilisis. Nulla tempor lobortis orci, at elementum urna sodales vitae. In in vehicula nulla, quis ornare libero. Left Center Right Lorem dolor amet ipsum sit Vestibulum vitae orci quis ante viverra ultricies ut eget turpis. Sed eu lectus dapibus, eleifend nulla varius, lobortis turpis. In ac hendrerit nisl, sit amet laoreet nibh. Table with colgroups (Pandoc) Lorem ipsum dolor sit amet. Sed sagittis eleifend rutrum. Donec vitae suscipit est. Admonition optional explicit title within double quotes Any number of other indented markdown elements. This is the second paragraph. Note You should note that the title will be automatically capitalized. Don\u2019t try this at home \u2026 This is an admonition box without a title. rST suggests the following \u201ctypes\u201d: attention , caution , danger , error , hint , important , note , tip , and warning ; however, you\u2019re free to use whatever you want.","title":"Specimen"},{"location":"specimen/#specimen","text":"","title":"Specimen"},{"location":"specimen/#body-copy","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras arcu libero, mollis sed massa vel, ornare viverra ex . Mauris a ullamcorper lacus. Nullam urna elit, malesuada eget finibus ut, ullamcorper ac tortor. Vestibulum sodales pulvinar nisl, pharetra aliquet est. Quisque volutpat erat ac nisi accumsan tempor. Sed suscipit , orci non pretium pretium, quam mi gravida metus, vel venenatis justo est condimentum diam. Maecenas non ornare justo. Nam a ipsum eros. Nulla aliquam orci sit amet nisl posuere malesuada. Proin aliquet nulla velit, quis ultricies orci feugiat et. Ut tincidunt sollicitudin tincidunt. Aenean ullamcorper sit amet nulla at interdum.","title":"Body copy"},{"location":"specimen/#headings","text":"","title":"Headings"},{"location":"specimen/#the-3rd-level","text":"","title":"The 3rd level"},{"location":"specimen/#the-4th-level","text":"","title":"The 4th level"},{"location":"specimen/#the-5th-level","text":"","title":"The 5th level"},{"location":"specimen/#the-6th-level","text":"","title":"The 6th level"},{"location":"specimen/#headings-with-secondary-text","text":"","title":"Headings with secondary text"},{"location":"specimen/#the-3rd-level-with-secondary-text","text":"","title":"The 3rd level with secondary text"},{"location":"specimen/#the-4th-level-with-secondary-text","text":"","title":"The 4th level with secondary text"},{"location":"specimen/#the-5th-level-with-secondary-text","text":"","title":"The 5th level with secondary text"},{"location":"specimen/#the-6th-level-with-secondary-text","text":"","title":"The 6th level with secondary text"},{"location":"specimen/#blockquotes","text":"Morbi eget dapibus felis. Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a. Nam vehicula nunc mauris, a ultricies libero efficitur sed. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Sed molestie imperdiet consectetur.","title":"Blockquotes"},{"location":"specimen/#blockquote-nesting","text":"Sed aliquet , neque at rutrum mollis, neque nisi tincidunt nibh, vitae faucibus lacus nunc at lacus. Nunc scelerisque, quam id cursus sodales, lorem libero fermentum urna, ut efficitur elit ligula et nunc. Mauris dictum mi lacus, sit amet pellentesque urna vehicula fringilla. Ut sit amet placerat ante. Proin sed elementum nulla. Nunc vitae sem odio. Suspendisse ac eros arcu. Vivamus orci erat, volutpat a tempor et, rutrum. eu odio. Suspendisse rutrum facilisis risus , eu posuere neque commodo a. Interdum et malesuada fames ac ante ipsum primis in faucibus. Sed nec leo bibendum, sodales mauris ut, tincidunt massa.","title":"Blockquote nesting"},{"location":"specimen/#other-content-blocks","text":"Vestibulum vitae orci quis ante viverra ultricies ut eget turpis. Sed eu lectus dapibus, eleifend nulla varius, lobortis turpis. In ac hendrerit nisl, sit amet laoreet nibh. js hl_lines=\"8\" var _extends = function(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { target[key] = source[key]; } } return target; }; Praesent at :::js return target , sodales nibh vel, tempor felis. Fusce vel lacinia lacus. Suspendisse rhoncus nunc non nisi iaculis ultrices. Donec consectetur mauris non neque imperdiet, eget volutpat libero.","title":"Other content blocks"},{"location":"specimen/#lists","text":"","title":"Lists"},{"location":"specimen/#unordered-lists","text":"Sed sagittis eleifend rutrum. Donec vitae suscipit est. Nullam tempus tellus non sem sollicitudin, quis rutrum leo facilisis. Nulla tempor lobortis orci, at elementum urna sodales vitae. In in vehicula nulla, quis ornare libero. Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis. Nam vulputate tincidunt fringilla. Nullam dignissim ultrices urna non auctor. Aliquam metus eros, pretium sed nulla venenatis, faucibus auctor ex. Proin ut eros sed sapien ullamcorper consequat. Nunc ligula ante, fringilla at aliquam ac, aliquet sed mauris. Nulla et rhoncus turpis. Mauris ultricies elementum leo. Duis efficitur accumsan nibh eu mattis. Vivamus tempus velit eros, porttitor placerat nibh lacinia sed. Aenean in finibus diam.","title":"Unordered lists"},{"location":"specimen/#ordered-lists","text":"Integer vehicula feugiat magna, a mollis tellus. Nam mollis ex ante, quis elementum eros tempor rutrum. Aenean efficitur lobortis lacinia. Nulla consectetur feugiat sodales. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Aliquam ornare feugiat quam et egestas. Nunc id erat et quam pellentesque lacinia eu vel odio. Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a. Nam vehicula nunc mauris, a ultricies libero efficitur sed. Mauris dictum mi lacus Ut sit amet placerat ante Suspendisse ac eros arcu Morbi eget dapibus felis. Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a. Sed aliquet, neque at rutrum mollis, neque nisi tincidunt nibh. Pellentesque eget :::js var _extends ornare tellus, ut gravida mi. js hl_lines=\"1\" var _extends = function(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { target[key] = source[key]; } } return target; }; Vivamus id mi enim. Integer id turpis sapien. Ut condimentum lobortis sagittis. Aliquam purus tellus, faucibus eget urna at, iaculis venenatis nulla. Vivamus a pharetra leo.","title":"Ordered lists"},{"location":"specimen/#definition-lists","text":"Lorem ipsum dolor sit amet : Sed sagittis eleifend rutrum. Donec vitae suscipit est. Nullam tempus tellus non sem sollicitudin, quis rutrum leo facilisis. Nulla tempor lobortis orci, at elementum urna sodales vitae. In in vehicula nulla. Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis. Nam vulputate tincidunt fringilla. Nullam dignissim ultrices urna non auctor. Cras arcu libero : Aliquam metus eros, pretium sed nulla venenatis, faucibus auctor ex. Proin ut eros sed sapien ullamcorper consequat. Nunc ligula ante, fringilla at aliquam ac, aliquet sed mauris.","title":"Definition lists"},{"location":"specimen/#code-blocks","text":"","title":"Code blocks"},{"location":"specimen/#inline","text":"Morbi eget dapibus felis . Vivamus venenatis porttitor tortor sit amet rutrum. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque aliquet quam enim , eu volutpat urna rutrum a. Nam vehicula nunc :::js return target mauris, a ultricies libero efficitur sed. Sed molestie imperdiet consectetur. Vivamus a pharetra leo. Pellentesque eget ornare tellus, ut gravida mi. Fusce vel lacinia lacus.","title":"Inline"},{"location":"specimen/#listing","text":"1 2 3 4 5 6 7 8 9 var _extends = function ( target ) { for ( var i = 1 ; i < arguments . length ; i ++ ) { var source = arguments [ i ]; for ( var key in source ) { target [ key ] = source [ key ]; } } return target ; };","title":"Listing"},{"location":"specimen/#horizontal-rules","text":"Aenean in finibus diam. Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis. Nam vulputate tincidunt fringilla. Nullam dignissim ultrices urna non auctor. Integer vehicula feugiat magna, a mollis tellus. Nam mollis ex ante, quis elementum eros tempor rutrum. Aenean efficitur lobortis lacinia. Nulla consectetur feugiat sodales.","title":"Horizontal rules"},{"location":"specimen/#data-tables","text":"Sollicitudo / Pellentesi consectetur adipiscing elit arcu sed Vivamus a pharetra yes yes yes yes yes Ornare viverra ex yes yes yes yes yes Mauris a ullamcorper yes yes partial yes yes Nullam urna elit yes yes yes yes yes Malesuada eget finibus yes yes yes yes yes Ullamcorper yes yes yes yes yes Vestibulum sodales yes - yes - yes Pulvinar nisl yes yes yes - - Pharetra aliquet est yes yes yes yes yes Sed suscipit yes yes yes yes yes Orci non pretium yes partial - - - Sed sagittis eleifend rutrum. Donec vitae suscipit est. Nullam tempus tellus non sem sollicitudin, quis rutrum leo facilisis. Nulla tempor lobortis orci, at elementum urna sodales vitae. In in vehicula nulla, quis ornare libero. Left Center Right Lorem dolor amet ipsum sit Vestibulum vitae orci quis ante viverra ultricies ut eget turpis. Sed eu lectus dapibus, eleifend nulla varius, lobortis turpis. In ac hendrerit nisl, sit amet laoreet nibh. Table with colgroups (Pandoc) Lorem ipsum dolor sit amet. Sed sagittis eleifend rutrum. Donec vitae suscipit est.","title":"Data tables"},{"location":"specimen/#admonition","text":"optional explicit title within double quotes Any number of other indented markdown elements. This is the second paragraph. Note You should note that the title will be automatically capitalized. Don\u2019t try this at home \u2026 This is an admonition box without a title. rST suggests the following \u201ctypes\u201d: attention , caution , danger , error , hint , important , note , tip , and warning ; however, you\u2019re free to use whatever you want.","title":"Admonition"},{"location":"cmds/","text":"This is the first paragraph of the document.","title":"My Document"},{"location":"cmds/advanced/","text":"This is the first paragraph of the document.","title":"My Document"},{"location":"cmds/common/alias/","text":"This is the first paragraph of the document.","title":"alias"},{"location":"cmds/common/cat/","text":"This is the first paragraph of the document.","title":"cat"},{"location":"cmds/common/cd/","text":"This is the first paragraph of the document.","title":"cd"},{"location":"cmds/common/clear/","text":"This is the first paragraph of the document.","title":"clear"},{"location":"cmds/common/cp/","text":"This is the first paragraph of the document.","title":"cp"},{"location":"cmds/common/date/","text":"This is the first paragraph of the document.","title":"date"},{"location":"cmds/common/echo/","text":"This is the first paragraph of the document.","title":"echo"},{"location":"cmds/common/grep/","text":"This is the first paragraph of the document.","title":"grep"},{"location":"cmds/common/head/","text":"This is the first paragraph of the document.","title":"head"},{"location":"cmds/common/history/","text":"This is the first paragraph of the document.","title":"history"},{"location":"cmds/common/kill/","text":"This is the first paragraph of the document.","title":"kill"},{"location":"cmds/common/killall/","text":"This is the first paragraph of the document.","title":"killall"},{"location":"cmds/common/less/","text":"This is the first paragraph of the document.","title":"less"},{"location":"cmds/common/ls/","text":"This is the first paragraph of the document.","title":"ls"},{"location":"cmds/common/man/","text":"This is the first paragraph of the document.","title":"man"},{"location":"cmds/common/mkdir/","text":"This is the first paragraph of the document.","title":"mkdir"},{"location":"cmds/common/more/","text":"This is the first paragraph of the document.","title":"more"},{"location":"cmds/common/mv/","text":"This is the first paragraph of the document.","title":"mv"},{"location":"cmds/common/pwd/","text":"This is the first paragraph of the document.","title":"pwd"},{"location":"cmds/common/rm/","text":"This is the first paragraph of the document.","title":"rm"},{"location":"cmds/common/rmdir/","text":"This is the first paragraph of the document.","title":"rmdir"},{"location":"cmds/common/tail/","text":"This is the first paragraph of the document.","title":"tail"},{"location":"cmds/common/touch/","text":"This is the first paragraph of the document.","title":"touch"},{"location":"fs/","text":"This is the first paragraph of the document.","title":"Filesystem"},{"location":"shell/shell/","text":"Unix shell is a command-line interpreter or shell that provides a command line user interface for Unix-like operating systems. The shell is both an interactive command language and a scripting language, and is used by the operating system to control the execution of the system using shell scripts. Shell Operation Variables $PATH Pattern Matching Shell Expansions Alias Exit Status Pipes and Redirections Lists of Commands Shell Scripts Condicionals If,else & If else Examples Case Loops Functions Variables Scope Return Values Arguments Shell Operation The following is a brief description of the shell\u2019s operation when it reads and executes a command. Basically, the shell does the following: Reads its input from a file (see Shell Scripts ) or from the user\u2019s terminal. Breaks the input into words and operators. These tokens are separated by metacharacters. Alias expansion is performed by this step (see Alias ). Parses the tokens into simple and compound commands. Performs the various shell expansions, breaking the expanded tokens into lists of filenames and commands and arguments. Performs any necessary redirections (see Pipes and Redirections ) and removes the redirection operators and their operands from the argument list. Executes the command. Optionally waits for the command to complete and collects its exit status (see Exit Status). Variables As in any other programming language, the shell has variables, these variables do not have any datatype as they can store a number, a character, a string of characters or lists. All variables are global to the current shell session (but not to a sub-process) The standard practice is that variables are always in uppercase, but there is no technical reason why they can\u2019t be in lowercase. To create a variable name it, and assign a value to it MY_VAR = \"hello\" To access a variable, add the $ prefix to the name of the variable echo $MY_VAR The shell can also, expand variables within strings created by double-quotes \" echo \"The value of MY_VAR is $MY_VAR \" Using export in front of a variable makes the variable available to sub-processes. This variables, also call Environment Variables export JAVA_HOME = /opt/java Variables are always expanded before running the command (step 4, of Shell Operation) Shells like bash, zsh, and fish will run scripts on there initialization that populate variables, this scripts can for all users, and each user can define it\u2019s own (.bashrc or .bash_profile for bash, .zshrc for zsh) in user\u2019s home dirrectory. These variables will be always present in the shell session. Examples of these variables are: USER, current user name HOSTNAME, name of the machine SHELL, current shell PATH, list of directories where the shell will look up for commands. $PATH The $PATH variable is one of the most important variable in a shell session, since it\u2019s a list of directories where the shell will look for executables (binaries, or scripts). The shell will always use the first binary found, so a user can override this variable to change which binary will be used. This change can done to a current shell session or make it permanent by adding the override in the shell initialization script. export PATH = /my/bin/location: $PATH Pattern Matching Also known as globbing or glob, is a term used to describe the expansion or the match of values returned when using wildcards, regular expressions, or other pattern matches. The special pattern characters (or wildcards) have the following meanings: * Matches any string, including the null string. ? Matches any single character. [\u2026] Matches any one of the enclosed characters. A pair of characters separated by a hyphen denotes a range expression; ?(pattern-list) Matches zero or one occurrence of the given patterns. *(pattern-list) Matches zero or more occurrences of the given patterns. +(pattern-list) Matches one or more occurrences of the given patterns. @(pattern-list) Matches one of the given patterns. !(pattern-list) Matches anything except one of the given patterns. Examples: ls *.jar ls ch [ e ] * Shell Expansions An expansion is performed on the command line after it has been split into tokens. There are seven kinds of expansion performed: brace expansion Brace expansion is a mechanism by which arbitrary strings may be generated. echo a { d,c,b } e tilde expansion The tilde (~) may be used to refer your own home directory or other users home directory. If the tilde-prefix is a ~+, the value of the shell variable PWD replaces the tilde-prefix If the tilde-prefix is a ~-, the value of the shell variable OLDPWD, if it is set, is substituted. ls ~ cd /etc pwd cd /bin pwd echo $OLDPWD # display /etc/ directory listing and not /bin ls ~- parameter and variable expansion The \u2018$\u2019 character introduces parameter expansion, command substitution, or arithmetic expansion. string = 01234567890abcdefgh echo ${ string : 7 } echo ${ string : -7: 2 } ommand substitution allows the output of a command to replace the command itself. $( command ) ` command ` arithmetic expansion allows the evaluation of an arithmetic expression and the substitution of the result. $(( expression )) process substitution allows a process\u2019s input or output to be referred to using a filename. < ( list ) > ( list ) word splitting The shell scans the results of parameter expansion, command substitution, and arithmetic expansion that did not occur within double quotes for word splitting. filename expansion Alias An alias is a keyboard shortcut, an abbreviation to avoiding typing a long command sequence alias la = ls -alh The command-line will automatically be replaced la with ls -alh Aliases can be set by shell session or, permanent by adding them in the shell initialization script. Aliases can be named same as commands, this aliases will take priority over the actual command regardless of its position in the $PATH variable this is useful when, we want to add default arguments and options to the command, for example alias grep = 'grep --color' List of common and useful aliases. # Search Through Terminal History alias hs = 'history | grep' #Open file with admin access alias snano = 'sudo nano' #clear terminal screen alias c = 'clear' # Shows all open ports alias ports = 'netstat -tulanp' #Tail a file alias t = 'tail -f' Exit Status The Portable Operating System Interface (POSIX) defines that all process should have an exit code. Exit codes are a number between 0 and 255, which is returned by any Unix command when it returns control to its parent process. 0 always means that the command was run successfully, any other number, will be interpreted as an error by the shell. Most POSIX compliant shells will store the Exit code in a variable named $? ls echo $? ls IdontExist echo $? The first echo $? will return 0 , since ls run without any issue, The following echo $? will return 2 since, ls was not run successfully, since, IdontExist well, does not exists. Pipes and Redirections Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface. \u2014 Peter H. Salus. A Quarter-Century of Unix. Addison-Wesley. 1994. ISBN 0-201-54777-5. Commands can send and receive output from other commands using pipelines and redirections. They both do the same basic thing; they redirect a file descriptor of the process executed. Pipe is used to pass output to another program or utility. Redirect is used to pass output to either a file or stream. A pipeline is a sequence of one or more commands separated by one of the control operators \u2018|\u2019 or \u2018|&\u2019. The output of each command in the pipeline is connected via a pipe to the input of the next command. That is, each command reads the previous command\u2019s output. ls | head -3 In the example above we send the output of ls to head -3 so we only print the first 3 results of ls A pipe connects the stdout of one process to the stdin of another. Redirection allows commands\u2019 file handles to be duplicated, opened, closed, made to refer to different files, and can change the files the command reads from and writes to. At any given time there are always three default files descriptors open, stdin (the keyboard), stdout (the screen), and stderr (error messages output to the screen). The file descriptors for stdin , stdout , and stderr are 0 , 1 , and 2 , respectively. > ( > is the same as 1> ) is the simplest redirection, this will redirect all stdout to a given file. ls > results.txt This will redirect the output of ls to a file named results.txt We can also \u201cmerge\u201d two file descriptors to point to the same file, this is useful when we want to have the output of stdout and stderr in the same file. To point them to the same file descriptor we use 2>&1 ( same as &>) That means that the output of 2 ( stderr ) should be redirected to 1 ( stdout ). ls 2 > & 1 > output.txt In this sequence, we tell the shell that we want the output of stderr (2) to be redirected to stdout (1) and the second > will send the output of stdout (now merge with stderr ) to a file name output.txt Redirrections will delete any information at there destination before writing anything, to avoid that the >> redirect should be used, when used, it will append the new output at the end of the destination. It is also possible to redirect stdin of a command by using < this will read the given file descriptor and send it to the command stdin . cat < myFile.txt By default cat will listen to stdin until the EOF character (ctrl-d) is sent. In the past example, change stdin to be a file. Lists of Commands It\u2019s possible to run multiple commands as a single line making a list of commands to be run, the list is made by using ; between the commands that we want to run. command1 ; command2 ; command 3 | command3.1 > myoutput.txt ; command 4 It\u2019s also possible to run the next command depending on the exit value by using && (AND) or || (OR) command1 && command2 command2 is executed if, and only if, command1 returns an exits status of zero (success). command1 || command2 command2 is executed if, and only if, command1 returns a non-zero exit status. The return status of AND and OR lists is the exit status of the last command executed in the list \u2018&&\u2019 and \u2018||\u2019 have equal precedence, followed by \u2018;\u2019 and \u2018&\u2019, which have equal precedence Shell Scripts Shells can also read a file, and execute the commands within the file this file is commonly known as shell scripts. Each shell can have its own syntax for these files, but in this guide, we will use the most common syntax, the sh which is also compatible with zsh shell. It\u2019s common to add #! as the first line of the scripts, this tells the shell which interpreter should be used to execute the script. #! is also known as shebang and its always followed by the full path of the interpreter that will run the script. #!/usr/bin/bash echo \"Hello World\" This will make our file to be interpreted by bash, it\u2019s also possible to use other interpreters like python, ruby, nodejs and since Java 10, Java. #!/usr/bin/python3 print ( \"Hello World\" ) #!/usr/bin/env node const http = require ( 'http' ) ; const hostname = '127.0.0.1' ; const port = 3000 ; const server = http.createServer (( req, res ) = > { res.statusCode = 200 ; res.setHeader ( 'Content-Type' , 'text/plain' ) ; res.end ( 'Hello World\\n' ) ; }) ; server.listen ( port, hostname, () = > { console.log ( ` Server running at http:// ${ hostname } : ${ port } / ` ) ; }) ; It is possible to the a script to use a specific version of a interpreter like the python example, or let the environment decided (node js example) which interpreter will be used (usualy, its the first found in the $PATH variable), the latter is the best practice. Condicionals If,else & If else The test-commands list is executed, and if its return status is zero, the consequent-commands list is executed. If if [ test-commands ] ; then <commands> fi If else if [ test-commands ] then <commands> else <other commands> fi If else if else if [ test-commands ] then <commands> elif [ test-commands ] then <different commands> else <other commands> fi Test Expressions ! EXPRESSION The EXPRESSION is false. -n STRING The length of STRING is greater than zero. -z STRING The lengh of STRING is zero (ie it is empty). STRING1 = STRING2 STRING1 is equal to STRING2 STRING1 != STRING2 STRING1 is not equal to STRING2 INTEGER1 -eq INTEGER2 INTEGER1 is numerically equal to INTEGER2 INTEGER1 -gt INTEGER2 INTEGER1 is numerically greater than INTEGER2 INTEGER1 -lt INTEGER2 INTEGER1 is numerically less than INTEGER2 INTEGER1 -ge INTEGER2 INTEGER1 is numerically greater or equal than INTEGER2 INTEGER1 -le INTEGER2 INTEGER1 is numerically less or equal than INTEGER2 -d FILE FILE exists and is a directory. -e FILE FILE exists. -r FILE FILE exists and the read permission is granted. -s FILE FILE exists and it\u2019s size is greater than zero (ie. it is not empty). -w FILE FILE exists and the write permission is granted. -x FILE FILE exists and the execute permission is granted. Examples if [ $value -eq 1 ] then echo \"has value\" fi my_file = \"myfile.txt\" if [ -s $my_file ] then cat $my_file else echo \"File not found\" fi my_var = 2 if [ $my_var -gt 0 ] then echo \"More than 2\" elif [ $my_var -lt 0 ] then echo \"it's negative\" else echo \"it's zero\" fi Case case will selectively execute the command-list corresponding to the first pattern that matches the word. case <variable> in <pattern 1 > ) commands ;; <pattern 2 > ) other_command ;; * ) defautl_command ;; esac case $action in start ) echo starting ;; stop ) echo stoping ;; restart ) echo restarting ;; * ) echo don \\' t know ;; esac Loops until Execute consequent-commands as long as test-commands has an exit status which is not zero. until test-commands ; do consequent-commands ; done count = 1 until [ $count -gt 5 ] do printf \"Count has a value of $count \\n\" (( count++ )) done while Execute consequent-commands as long as test-commands has an exit status of zero. while test-commands ; do consequent-commands ; don i = \"0\" while [ $i -lt 4 ] do echo \" $i \" i = $ [ $i +1 ] done for Expand words (see Shell Expansions), and execute commands once for each member in the resultant list, with name bound to the current member (as internal loop variable $name) for name [ [ in [ words \u2026 ] ] ; ] do commands ; done for (( expr1 ; expr2 ; expr3 )) ; do commands ; done for file in $( ls ) ; do echo \"File is $file \" ; done Functions A function is essentially a set of commands that can be called numerous times. The purpose of a function is to help you make your bash scripts more readable and to avoid writing the same code over and over again. function_name () { commands } function function_name { commands } Variables can also have, the same name as commands, like an alias, this will always take precedence over the actual command. Since all shell scripts are interpreted, functions must be declared, before using them. Variables Scope Global variables are variables that can be accessed from anywhere in the script regardless of the scope. All variables by default are defined as global, even if declared inside the function. Local variables can be declared within the function body with the local keyword and can be used only inside that function. #!/bin/bash var1 = 'A' var2 = 'B' my_function () { local var1 = 'C' var2 = 'D' echo \"Inside function: var1: $var1 , var2: $var2 \" } echo \"Before executing function: var1: $var1 , var2: $var2 \" my_function echo \"After executing function: var1: $var1 , var2: $var2 \" Return Values When a function completes, its return value is the status of the last statement executed in the function my_function () { echo \"some result\" return 55 } my_function echo $? Arguments To pass any number of arguments to the bash function simply put them right after the function\u2019s name It is a best practice to double quote the arguments *The passed parameters are $1 , $2 , $3 \u2026 $n , corresponding to the position of the parameter after the function\u2019s name., The $0 variable is reserved for the function\u2019s name. The `$# variable holds the number of positional parameters/arguments passed to the function. The $* or $@ variable holds all positional parameters/arguments passed to the function. greeting () { echo \"Hello $1 \" } greeting \"Joe\"","title":"Shell"},{"location":"shell/shell/#shell-operation","text":"The following is a brief description of the shell\u2019s operation when it reads and executes a command. Basically, the shell does the following: Reads its input from a file (see Shell Scripts ) or from the user\u2019s terminal. Breaks the input into words and operators. These tokens are separated by metacharacters. Alias expansion is performed by this step (see Alias ). Parses the tokens into simple and compound commands. Performs the various shell expansions, breaking the expanded tokens into lists of filenames and commands and arguments. Performs any necessary redirections (see Pipes and Redirections ) and removes the redirection operators and their operands from the argument list. Executes the command. Optionally waits for the command to complete and collects its exit status (see Exit Status).","title":"Shell Operation"},{"location":"shell/shell/#variables","text":"As in any other programming language, the shell has variables, these variables do not have any datatype as they can store a number, a character, a string of characters or lists. All variables are global to the current shell session (but not to a sub-process) The standard practice is that variables are always in uppercase, but there is no technical reason why they can\u2019t be in lowercase. To create a variable name it, and assign a value to it MY_VAR = \"hello\" To access a variable, add the $ prefix to the name of the variable echo $MY_VAR The shell can also, expand variables within strings created by double-quotes \" echo \"The value of MY_VAR is $MY_VAR \" Using export in front of a variable makes the variable available to sub-processes. This variables, also call Environment Variables export JAVA_HOME = /opt/java Variables are always expanded before running the command (step 4, of Shell Operation) Shells like bash, zsh, and fish will run scripts on there initialization that populate variables, this scripts can for all users, and each user can define it\u2019s own (.bashrc or .bash_profile for bash, .zshrc for zsh) in user\u2019s home dirrectory. These variables will be always present in the shell session. Examples of these variables are: USER, current user name HOSTNAME, name of the machine SHELL, current shell PATH, list of directories where the shell will look up for commands.","title":"Variables"},{"location":"shell/shell/#path","text":"The $PATH variable is one of the most important variable in a shell session, since it\u2019s a list of directories where the shell will look for executables (binaries, or scripts). The shell will always use the first binary found, so a user can override this variable to change which binary will be used. This change can done to a current shell session or make it permanent by adding the override in the shell initialization script. export PATH = /my/bin/location: $PATH","title":"$PATH"},{"location":"shell/shell/#pattern-matching","text":"Also known as globbing or glob, is a term used to describe the expansion or the match of values returned when using wildcards, regular expressions, or other pattern matches. The special pattern characters (or wildcards) have the following meanings: * Matches any string, including the null string. ? Matches any single character. [\u2026] Matches any one of the enclosed characters. A pair of characters separated by a hyphen denotes a range expression; ?(pattern-list) Matches zero or one occurrence of the given patterns. *(pattern-list) Matches zero or more occurrences of the given patterns. +(pattern-list) Matches one or more occurrences of the given patterns. @(pattern-list) Matches one of the given patterns. !(pattern-list) Matches anything except one of the given patterns. Examples: ls *.jar ls ch [ e ] *","title":"Pattern Matching"},{"location":"shell/shell/#shell-expansions","text":"An expansion is performed on the command line after it has been split into tokens. There are seven kinds of expansion performed: brace expansion Brace expansion is a mechanism by which arbitrary strings may be generated. echo a { d,c,b } e tilde expansion The tilde (~) may be used to refer your own home directory or other users home directory. If the tilde-prefix is a ~+, the value of the shell variable PWD replaces the tilde-prefix If the tilde-prefix is a ~-, the value of the shell variable OLDPWD, if it is set, is substituted. ls ~ cd /etc pwd cd /bin pwd echo $OLDPWD # display /etc/ directory listing and not /bin ls ~- parameter and variable expansion The \u2018$\u2019 character introduces parameter expansion, command substitution, or arithmetic expansion. string = 01234567890abcdefgh echo ${ string : 7 } echo ${ string : -7: 2 } ommand substitution allows the output of a command to replace the command itself. $( command ) ` command ` arithmetic expansion allows the evaluation of an arithmetic expression and the substitution of the result. $(( expression )) process substitution allows a process\u2019s input or output to be referred to using a filename. < ( list ) > ( list ) word splitting The shell scans the results of parameter expansion, command substitution, and arithmetic expansion that did not occur within double quotes for word splitting. filename expansion","title":"Shell Expansions"},{"location":"shell/shell/#alias","text":"An alias is a keyboard shortcut, an abbreviation to avoiding typing a long command sequence alias la = ls -alh The command-line will automatically be replaced la with ls -alh Aliases can be set by shell session or, permanent by adding them in the shell initialization script. Aliases can be named same as commands, this aliases will take priority over the actual command regardless of its position in the $PATH variable this is useful when, we want to add default arguments and options to the command, for example alias grep = 'grep --color' List of common and useful aliases. # Search Through Terminal History alias hs = 'history | grep' #Open file with admin access alias snano = 'sudo nano' #clear terminal screen alias c = 'clear' # Shows all open ports alias ports = 'netstat -tulanp' #Tail a file alias t = 'tail -f'","title":"Alias"},{"location":"shell/shell/#exit-status","text":"The Portable Operating System Interface (POSIX) defines that all process should have an exit code. Exit codes are a number between 0 and 255, which is returned by any Unix command when it returns control to its parent process. 0 always means that the command was run successfully, any other number, will be interpreted as an error by the shell. Most POSIX compliant shells will store the Exit code in a variable named $? ls echo $? ls IdontExist echo $? The first echo $? will return 0 , since ls run without any issue, The following echo $? will return 2 since, ls was not run successfully, since, IdontExist well, does not exists.","title":"Exit Status"},{"location":"shell/shell/#pipes-and-redirections","text":"Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface. \u2014 Peter H. Salus. A Quarter-Century of Unix. Addison-Wesley. 1994. ISBN 0-201-54777-5. Commands can send and receive output from other commands using pipelines and redirections. They both do the same basic thing; they redirect a file descriptor of the process executed. Pipe is used to pass output to another program or utility. Redirect is used to pass output to either a file or stream. A pipeline is a sequence of one or more commands separated by one of the control operators \u2018|\u2019 or \u2018|&\u2019. The output of each command in the pipeline is connected via a pipe to the input of the next command. That is, each command reads the previous command\u2019s output. ls | head -3 In the example above we send the output of ls to head -3 so we only print the first 3 results of ls A pipe connects the stdout of one process to the stdin of another. Redirection allows commands\u2019 file handles to be duplicated, opened, closed, made to refer to different files, and can change the files the command reads from and writes to. At any given time there are always three default files descriptors open, stdin (the keyboard), stdout (the screen), and stderr (error messages output to the screen). The file descriptors for stdin , stdout , and stderr are 0 , 1 , and 2 , respectively. > ( > is the same as 1> ) is the simplest redirection, this will redirect all stdout to a given file. ls > results.txt This will redirect the output of ls to a file named results.txt We can also \u201cmerge\u201d two file descriptors to point to the same file, this is useful when we want to have the output of stdout and stderr in the same file. To point them to the same file descriptor we use 2>&1 ( same as &>) That means that the output of 2 ( stderr ) should be redirected to 1 ( stdout ). ls 2 > & 1 > output.txt In this sequence, we tell the shell that we want the output of stderr (2) to be redirected to stdout (1) and the second > will send the output of stdout (now merge with stderr ) to a file name output.txt Redirrections will delete any information at there destination before writing anything, to avoid that the >> redirect should be used, when used, it will append the new output at the end of the destination. It is also possible to redirect stdin of a command by using < this will read the given file descriptor and send it to the command stdin . cat < myFile.txt By default cat will listen to stdin until the EOF character (ctrl-d) is sent. In the past example, change stdin to be a file.","title":"Pipes and Redirections"},{"location":"shell/shell/#lists-of-commands","text":"It\u2019s possible to run multiple commands as a single line making a list of commands to be run, the list is made by using ; between the commands that we want to run. command1 ; command2 ; command 3 | command3.1 > myoutput.txt ; command 4 It\u2019s also possible to run the next command depending on the exit value by using && (AND) or || (OR) command1 && command2 command2 is executed if, and only if, command1 returns an exits status of zero (success). command1 || command2 command2 is executed if, and only if, command1 returns a non-zero exit status. The return status of AND and OR lists is the exit status of the last command executed in the list \u2018&&\u2019 and \u2018||\u2019 have equal precedence, followed by \u2018;\u2019 and \u2018&\u2019, which have equal precedence","title":"Lists of Commands"},{"location":"shell/shell/#shell-scripts","text":"Shells can also read a file, and execute the commands within the file this file is commonly known as shell scripts. Each shell can have its own syntax for these files, but in this guide, we will use the most common syntax, the sh which is also compatible with zsh shell. It\u2019s common to add #! as the first line of the scripts, this tells the shell which interpreter should be used to execute the script. #! is also known as shebang and its always followed by the full path of the interpreter that will run the script. #!/usr/bin/bash echo \"Hello World\" This will make our file to be interpreted by bash, it\u2019s also possible to use other interpreters like python, ruby, nodejs and since Java 10, Java. #!/usr/bin/python3 print ( \"Hello World\" ) #!/usr/bin/env node const http = require ( 'http' ) ; const hostname = '127.0.0.1' ; const port = 3000 ; const server = http.createServer (( req, res ) = > { res.statusCode = 200 ; res.setHeader ( 'Content-Type' , 'text/plain' ) ; res.end ( 'Hello World\\n' ) ; }) ; server.listen ( port, hostname, () = > { console.log ( ` Server running at http:// ${ hostname } : ${ port } / ` ) ; }) ; It is possible to the a script to use a specific version of a interpreter like the python example, or let the environment decided (node js example) which interpreter will be used (usualy, its the first found in the $PATH variable), the latter is the best practice.","title":"Shell Scripts"},{"location":"shell/shell/#condicionals","text":"","title":"Condicionals"},{"location":"shell/shell/#ifelse-if-else","text":"The test-commands list is executed, and if its return status is zero, the consequent-commands list is executed. If if [ test-commands ] ; then <commands> fi If else if [ test-commands ] then <commands> else <other commands> fi If else if else if [ test-commands ] then <commands> elif [ test-commands ] then <different commands> else <other commands> fi Test Expressions ! EXPRESSION The EXPRESSION is false. -n STRING The length of STRING is greater than zero. -z STRING The lengh of STRING is zero (ie it is empty). STRING1 = STRING2 STRING1 is equal to STRING2 STRING1 != STRING2 STRING1 is not equal to STRING2 INTEGER1 -eq INTEGER2 INTEGER1 is numerically equal to INTEGER2 INTEGER1 -gt INTEGER2 INTEGER1 is numerically greater than INTEGER2 INTEGER1 -lt INTEGER2 INTEGER1 is numerically less than INTEGER2 INTEGER1 -ge INTEGER2 INTEGER1 is numerically greater or equal than INTEGER2 INTEGER1 -le INTEGER2 INTEGER1 is numerically less or equal than INTEGER2 -d FILE FILE exists and is a directory. -e FILE FILE exists. -r FILE FILE exists and the read permission is granted. -s FILE FILE exists and it\u2019s size is greater than zero (ie. it is not empty). -w FILE FILE exists and the write permission is granted. -x FILE FILE exists and the execute permission is granted.","title":"If,else &amp; If else"},{"location":"shell/shell/#examples","text":"if [ $value -eq 1 ] then echo \"has value\" fi my_file = \"myfile.txt\" if [ -s $my_file ] then cat $my_file else echo \"File not found\" fi my_var = 2 if [ $my_var -gt 0 ] then echo \"More than 2\" elif [ $my_var -lt 0 ] then echo \"it's negative\" else echo \"it's zero\" fi","title":"Examples"},{"location":"shell/shell/#case","text":"case will selectively execute the command-list corresponding to the first pattern that matches the word. case <variable> in <pattern 1 > ) commands ;; <pattern 2 > ) other_command ;; * ) defautl_command ;; esac case $action in start ) echo starting ;; stop ) echo stoping ;; restart ) echo restarting ;; * ) echo don \\' t know ;; esac","title":"Case"},{"location":"shell/shell/#loops","text":"until Execute consequent-commands as long as test-commands has an exit status which is not zero. until test-commands ; do consequent-commands ; done count = 1 until [ $count -gt 5 ] do printf \"Count has a value of $count \\n\" (( count++ )) done while Execute consequent-commands as long as test-commands has an exit status of zero. while test-commands ; do consequent-commands ; don i = \"0\" while [ $i -lt 4 ] do echo \" $i \" i = $ [ $i +1 ] done for Expand words (see Shell Expansions), and execute commands once for each member in the resultant list, with name bound to the current member (as internal loop variable $name) for name [ [ in [ words \u2026 ] ] ; ] do commands ; done for (( expr1 ; expr2 ; expr3 )) ; do commands ; done for file in $( ls ) ; do echo \"File is $file \" ; done","title":"Loops"},{"location":"shell/shell/#functions","text":"A function is essentially a set of commands that can be called numerous times. The purpose of a function is to help you make your bash scripts more readable and to avoid writing the same code over and over again. function_name () { commands } function function_name { commands } Variables can also have, the same name as commands, like an alias, this will always take precedence over the actual command. Since all shell scripts are interpreted, functions must be declared, before using them.","title":"Functions"},{"location":"shell/shell/#variables-scope","text":"Global variables are variables that can be accessed from anywhere in the script regardless of the scope. All variables by default are defined as global, even if declared inside the function. Local variables can be declared within the function body with the local keyword and can be used only inside that function. #!/bin/bash var1 = 'A' var2 = 'B' my_function () { local var1 = 'C' var2 = 'D' echo \"Inside function: var1: $var1 , var2: $var2 \" } echo \"Before executing function: var1: $var1 , var2: $var2 \" my_function echo \"After executing function: var1: $var1 , var2: $var2 \"","title":"Variables Scope"},{"location":"shell/shell/#return-values","text":"When a function completes, its return value is the status of the last statement executed in the function my_function () { echo \"some result\" return 55 } my_function echo $?","title":"Return Values"},{"location":"shell/shell/#arguments","text":"To pass any number of arguments to the bash function simply put them right after the function\u2019s name It is a best practice to double quote the arguments *The passed parameters are $1 , $2 , $3 \u2026 $n , corresponding to the position of the parameter after the function\u2019s name., The $0 variable is reserved for the function\u2019s name. The `$# variable holds the number of positional parameters/arguments passed to the function. The $* or $@ variable holds all positional parameters/arguments passed to the function. greeting () { echo \"Hello $1 \" } greeting \"Joe\"","title":"Arguments"}]}