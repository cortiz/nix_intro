{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00b6","title":"Home"},{"location":"references/","text":"References and complementary documents. \u00b6 Bash Reference Manual Bash Functions The Z Shell Manual Until Loop Creating Bash Aliases Bash Guide for Beginners General overview of the Linux file system Understanding Linux File Permissions","title":"References"},{"location":"references/#references-and-complementary-documents","text":"Bash Reference Manual Bash Functions The Z Shell Manual Until Loop Creating Bash Aliases Bash Guide for Beginners General overview of the Linux file system Understanding Linux File Permissions","title":"References and complementary documents."},{"location":"specimen/","text":"Specimen \u00b6 Body copy \u00b6 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras arcu libero, mollis sed massa vel, ornare viverra ex . Mauris a ullamcorper lacus. Nullam urna elit, malesuada eget finibus ut, ullamcorper ac tortor. Vestibulum sodales pulvinar nisl, pharetra aliquet est. Quisque volutpat erat ac nisi accumsan tempor. Sed suscipit , orci non pretium pretium, quam mi gravida metus, vel venenatis justo est condimentum diam. Maecenas non ornare justo. Nam a ipsum eros. Nulla aliquam orci sit amet nisl posuere malesuada. Proin aliquet nulla velit, quis ultricies orci feugiat et. Ut tincidunt sollicitudin tincidunt. Aenean ullamcorper sit amet nulla at interdum. Headings \u00b6 The 3rd level \u00b6 The 4th level \u00b6 The 5th level \u00b6 The 6th level \u00b6 Headings with secondary text \u00b6 The 3rd level with secondary text \u00b6 The 4th level with secondary text \u00b6 The 5th level with secondary text \u00b6 The 6th level with secondary text \u00b6 Blockquotes \u00b6 Morbi eget dapibus felis. Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a. Nam vehicula nunc mauris, a ultricies libero efficitur sed. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Sed molestie imperdiet consectetur. Blockquote nesting \u00b6 Sed aliquet , neque at rutrum mollis, neque nisi tincidunt nibh, vitae faucibus lacus nunc at lacus. Nunc scelerisque, quam id cursus sodales, lorem libero fermentum urna, ut efficitur elit ligula et nunc. Mauris dictum mi lacus, sit amet pellentesque urna vehicula fringilla. Ut sit amet placerat ante. Proin sed elementum nulla. Nunc vitae sem odio. Suspendisse ac eros arcu. Vivamus orci erat, volutpat a tempor et, rutrum. eu odio. Suspendisse rutrum facilisis risus , eu posuere neque commodo a. Interdum et malesuada fames ac ante ipsum primis in faucibus. Sed nec leo bibendum, sodales mauris ut, tincidunt massa. Other content blocks \u00b6 Vestibulum vitae orci quis ante viverra ultricies ut eget turpis. Sed eu lectus dapibus, eleifend nulla varius, lobortis turpis. In ac hendrerit nisl, sit amet laoreet nibh. js hl_lines=\"8\" var _extends = function(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { target[key] = source[key]; } } return target; }; Praesent at :::js return target , sodales nibh vel, tempor felis. Fusce vel lacinia lacus. Suspendisse rhoncus nunc non nisi iaculis ultrices. Donec consectetur mauris non neque imperdiet, eget volutpat libero. Lists \u00b6 Unordered lists \u00b6 Sed sagittis eleifend rutrum. Donec vitae suscipit est. Nullam tempus tellus non sem sollicitudin, quis rutrum leo facilisis. Nulla tempor lobortis orci, at elementum urna sodales vitae. In in vehicula nulla, quis ornare libero. Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis. Nam vulputate tincidunt fringilla. Nullam dignissim ultrices urna non auctor. Aliquam metus eros, pretium sed nulla venenatis, faucibus auctor ex. Proin ut eros sed sapien ullamcorper consequat. Nunc ligula ante, fringilla at aliquam ac, aliquet sed mauris. Nulla et rhoncus turpis. Mauris ultricies elementum leo. Duis efficitur accumsan nibh eu mattis. Vivamus tempus velit eros, porttitor placerat nibh lacinia sed. Aenean in finibus diam. Ordered lists \u00b6 Integer vehicula feugiat magna, a mollis tellus. Nam mollis ex ante, quis elementum eros tempor rutrum. Aenean efficitur lobortis lacinia. Nulla consectetur feugiat sodales. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Aliquam ornare feugiat quam et egestas. Nunc id erat et quam pellentesque lacinia eu vel odio. Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a. Nam vehicula nunc mauris, a ultricies libero efficitur sed. Mauris dictum mi lacus Ut sit amet placerat ante Suspendisse ac eros arcu Morbi eget dapibus felis. Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a. Sed aliquet, neque at rutrum mollis, neque nisi tincidunt nibh. Pellentesque eget :::js var _extends ornare tellus, ut gravida mi. js hl_lines=\"1\" var _extends = function(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { target[key] = source[key]; } } return target; }; Vivamus id mi enim. Integer id turpis sapien. Ut condimentum lobortis sagittis. Aliquam purus tellus, faucibus eget urna at, iaculis venenatis nulla. Vivamus a pharetra leo. Definition lists \u00b6 Lorem ipsum dolor sit amet : Sed sagittis eleifend rutrum. Donec vitae suscipit est. Nullam tempus tellus non sem sollicitudin, quis rutrum leo facilisis. Nulla tempor lobortis orci, at elementum urna sodales vitae. In in vehicula nulla. Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis. Nam vulputate tincidunt fringilla. Nullam dignissim ultrices urna non auctor. Cras arcu libero : Aliquam metus eros, pretium sed nulla venenatis, faucibus auctor ex. Proin ut eros sed sapien ullamcorper consequat. Nunc ligula ante, fringilla at aliquam ac, aliquet sed mauris. Code blocks \u00b6 Inline \u00b6 Morbi eget dapibus felis . Vivamus venenatis porttitor tortor sit amet rutrum. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque aliquet quam enim , eu volutpat urna rutrum a. Nam vehicula nunc :::js return target mauris, a ultricies libero efficitur sed. Sed molestie imperdiet consectetur. Vivamus a pharetra leo. Pellentesque eget ornare tellus, ut gravida mi. Fusce vel lacinia lacus. Listing \u00b6 1 2 3 4 5 6 7 8 9 var _extends = function ( target ) { for ( var i = 1 ; i < arguments . length ; i ++ ) { var source = arguments [ i ]; for ( var key in source ) { target [ key ] = source [ key ]; } } return target ; }; Horizontal rules \u00b6 Aenean in finibus diam. Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis. Nam vulputate tincidunt fringilla. Nullam dignissim ultrices urna non auctor. Integer vehicula feugiat magna, a mollis tellus. Nam mollis ex ante, quis elementum eros tempor rutrum. Aenean efficitur lobortis lacinia. Nulla consectetur feugiat sodales. Data tables \u00b6 Sollicitudo / Pellentesi consectetur adipiscing elit arcu sed Vivamus a pharetra yes yes yes yes yes Ornare viverra ex yes yes yes yes yes Mauris a ullamcorper yes yes partial yes yes Nullam urna elit yes yes yes yes yes Malesuada eget finibus yes yes yes yes yes Ullamcorper yes yes yes yes yes Vestibulum sodales yes - yes - yes Pulvinar nisl yes yes yes - - Pharetra aliquet est yes yes yes yes yes Sed suscipit yes yes yes yes yes Orci non pretium yes partial - - - Sed sagittis eleifend rutrum. Donec vitae suscipit est. Nullam tempus tellus non sem sollicitudin, quis rutrum leo facilisis. Nulla tempor lobortis orci, at elementum urna sodales vitae. In in vehicula nulla, quis ornare libero. Left Center Right Lorem dolor amet ipsum sit Vestibulum vitae orci quis ante viverra ultricies ut eget turpis. Sed eu lectus dapibus, eleifend nulla varius, lobortis turpis. In ac hendrerit nisl, sit amet laoreet nibh. Table with colgroups (Pandoc) Lorem ipsum dolor sit amet. Sed sagittis eleifend rutrum. Donec vitae suscipit est. Admonition \u00b6 optional explicit title within double quotes Any number of other indented markdown elements. This is the second paragraph. Note You should note that the title will be automatically capitalized. Don\u2019t try this at home \u2026 This is an admonition box without a title. rST suggests the following \u201ctypes\u201d: attention , caution , danger , error , hint , important , note , tip , and warning ; however, you\u2019re free to use whatever you want.","title":"Specimen"},{"location":"specimen/#specimen","text":"","title":"Specimen"},{"location":"specimen/#body-copy","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras arcu libero, mollis sed massa vel, ornare viverra ex . Mauris a ullamcorper lacus. Nullam urna elit, malesuada eget finibus ut, ullamcorper ac tortor. Vestibulum sodales pulvinar nisl, pharetra aliquet est. Quisque volutpat erat ac nisi accumsan tempor. Sed suscipit , orci non pretium pretium, quam mi gravida metus, vel venenatis justo est condimentum diam. Maecenas non ornare justo. Nam a ipsum eros. Nulla aliquam orci sit amet nisl posuere malesuada. Proin aliquet nulla velit, quis ultricies orci feugiat et. Ut tincidunt sollicitudin tincidunt. Aenean ullamcorper sit amet nulla at interdum.","title":"Body copy"},{"location":"specimen/#headings","text":"","title":"Headings"},{"location":"specimen/#the-3rd-level","text":"","title":"The 3rd level"},{"location":"specimen/#the-4th-level","text":"","title":"The 4th level"},{"location":"specimen/#the-5th-level","text":"","title":"The 5th level"},{"location":"specimen/#the-6th-level","text":"","title":"The 6th level"},{"location":"specimen/#headings-with-secondary-text","text":"","title":"Headings with secondary text"},{"location":"specimen/#the-3rd-level-with-secondary-text","text":"","title":"The 3rd level with secondary text"},{"location":"specimen/#the-4th-level-with-secondary-text","text":"","title":"The 4th level with secondary text"},{"location":"specimen/#the-5th-level-with-secondary-text","text":"","title":"The 5th level with secondary text"},{"location":"specimen/#the-6th-level-with-secondary-text","text":"","title":"The 6th level with secondary text"},{"location":"specimen/#blockquotes","text":"Morbi eget dapibus felis. Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a. Nam vehicula nunc mauris, a ultricies libero efficitur sed. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Sed molestie imperdiet consectetur.","title":"Blockquotes"},{"location":"specimen/#blockquote-nesting","text":"Sed aliquet , neque at rutrum mollis, neque nisi tincidunt nibh, vitae faucibus lacus nunc at lacus. Nunc scelerisque, quam id cursus sodales, lorem libero fermentum urna, ut efficitur elit ligula et nunc. Mauris dictum mi lacus, sit amet pellentesque urna vehicula fringilla. Ut sit amet placerat ante. Proin sed elementum nulla. Nunc vitae sem odio. Suspendisse ac eros arcu. Vivamus orci erat, volutpat a tempor et, rutrum. eu odio. Suspendisse rutrum facilisis risus , eu posuere neque commodo a. Interdum et malesuada fames ac ante ipsum primis in faucibus. Sed nec leo bibendum, sodales mauris ut, tincidunt massa.","title":"Blockquote nesting"},{"location":"specimen/#other-content-blocks","text":"Vestibulum vitae orci quis ante viverra ultricies ut eget turpis. Sed eu lectus dapibus, eleifend nulla varius, lobortis turpis. In ac hendrerit nisl, sit amet laoreet nibh. js hl_lines=\"8\" var _extends = function(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { target[key] = source[key]; } } return target; }; Praesent at :::js return target , sodales nibh vel, tempor felis. Fusce vel lacinia lacus. Suspendisse rhoncus nunc non nisi iaculis ultrices. Donec consectetur mauris non neque imperdiet, eget volutpat libero.","title":"Other content blocks"},{"location":"specimen/#lists","text":"","title":"Lists"},{"location":"specimen/#unordered-lists","text":"Sed sagittis eleifend rutrum. Donec vitae suscipit est. Nullam tempus tellus non sem sollicitudin, quis rutrum leo facilisis. Nulla tempor lobortis orci, at elementum urna sodales vitae. In in vehicula nulla, quis ornare libero. Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis. Nam vulputate tincidunt fringilla. Nullam dignissim ultrices urna non auctor. Aliquam metus eros, pretium sed nulla venenatis, faucibus auctor ex. Proin ut eros sed sapien ullamcorper consequat. Nunc ligula ante, fringilla at aliquam ac, aliquet sed mauris. Nulla et rhoncus turpis. Mauris ultricies elementum leo. Duis efficitur accumsan nibh eu mattis. Vivamus tempus velit eros, porttitor placerat nibh lacinia sed. Aenean in finibus diam.","title":"Unordered lists"},{"location":"specimen/#ordered-lists","text":"Integer vehicula feugiat magna, a mollis tellus. Nam mollis ex ante, quis elementum eros tempor rutrum. Aenean efficitur lobortis lacinia. Nulla consectetur feugiat sodales. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Aliquam ornare feugiat quam et egestas. Nunc id erat et quam pellentesque lacinia eu vel odio. Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a. Nam vehicula nunc mauris, a ultricies libero efficitur sed. Mauris dictum mi lacus Ut sit amet placerat ante Suspendisse ac eros arcu Morbi eget dapibus felis. Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a. Sed aliquet, neque at rutrum mollis, neque nisi tincidunt nibh. Pellentesque eget :::js var _extends ornare tellus, ut gravida mi. js hl_lines=\"1\" var _extends = function(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { target[key] = source[key]; } } return target; }; Vivamus id mi enim. Integer id turpis sapien. Ut condimentum lobortis sagittis. Aliquam purus tellus, faucibus eget urna at, iaculis venenatis nulla. Vivamus a pharetra leo.","title":"Ordered lists"},{"location":"specimen/#definition-lists","text":"Lorem ipsum dolor sit amet : Sed sagittis eleifend rutrum. Donec vitae suscipit est. Nullam tempus tellus non sem sollicitudin, quis rutrum leo facilisis. Nulla tempor lobortis orci, at elementum urna sodales vitae. In in vehicula nulla. Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis. Nam vulputate tincidunt fringilla. Nullam dignissim ultrices urna non auctor. Cras arcu libero : Aliquam metus eros, pretium sed nulla venenatis, faucibus auctor ex. Proin ut eros sed sapien ullamcorper consequat. Nunc ligula ante, fringilla at aliquam ac, aliquet sed mauris.","title":"Definition lists"},{"location":"specimen/#code-blocks","text":"","title":"Code blocks"},{"location":"specimen/#inline","text":"Morbi eget dapibus felis . Vivamus venenatis porttitor tortor sit amet rutrum. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque aliquet quam enim , eu volutpat urna rutrum a. Nam vehicula nunc :::js return target mauris, a ultricies libero efficitur sed. Sed molestie imperdiet consectetur. Vivamus a pharetra leo. Pellentesque eget ornare tellus, ut gravida mi. Fusce vel lacinia lacus.","title":"Inline"},{"location":"specimen/#listing","text":"1 2 3 4 5 6 7 8 9 var _extends = function ( target ) { for ( var i = 1 ; i < arguments . length ; i ++ ) { var source = arguments [ i ]; for ( var key in source ) { target [ key ] = source [ key ]; } } return target ; };","title":"Listing"},{"location":"specimen/#horizontal-rules","text":"Aenean in finibus diam. Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis. Nam vulputate tincidunt fringilla. Nullam dignissim ultrices urna non auctor. Integer vehicula feugiat magna, a mollis tellus. Nam mollis ex ante, quis elementum eros tempor rutrum. Aenean efficitur lobortis lacinia. Nulla consectetur feugiat sodales.","title":"Horizontal rules"},{"location":"specimen/#data-tables","text":"Sollicitudo / Pellentesi consectetur adipiscing elit arcu sed Vivamus a pharetra yes yes yes yes yes Ornare viverra ex yes yes yes yes yes Mauris a ullamcorper yes yes partial yes yes Nullam urna elit yes yes yes yes yes Malesuada eget finibus yes yes yes yes yes Ullamcorper yes yes yes yes yes Vestibulum sodales yes - yes - yes Pulvinar nisl yes yes yes - - Pharetra aliquet est yes yes yes yes yes Sed suscipit yes yes yes yes yes Orci non pretium yes partial - - - Sed sagittis eleifend rutrum. Donec vitae suscipit est. Nullam tempus tellus non sem sollicitudin, quis rutrum leo facilisis. Nulla tempor lobortis orci, at elementum urna sodales vitae. In in vehicula nulla, quis ornare libero. Left Center Right Lorem dolor amet ipsum sit Vestibulum vitae orci quis ante viverra ultricies ut eget turpis. Sed eu lectus dapibus, eleifend nulla varius, lobortis turpis. In ac hendrerit nisl, sit amet laoreet nibh. Table with colgroups (Pandoc) Lorem ipsum dolor sit amet. Sed sagittis eleifend rutrum. Donec vitae suscipit est.","title":"Data tables"},{"location":"specimen/#admonition","text":"optional explicit title within double quotes Any number of other indented markdown elements. This is the second paragraph. Note You should note that the title will be automatically capitalized. Don\u2019t try this at home \u2026 This is an admonition box without a title. rST suggests the following \u201ctypes\u201d: attention , caution , danger , error , hint , important , note , tip , and warning ; however, you\u2019re free to use whatever you want.","title":"Admonition"},{"location":"cmds/","text":"This is the first paragraph of the document.","title":"My Document"},{"location":"cmds/advanced/","text":"This is the first paragraph of the document.","title":"My Document"},{"location":"cmds/common/alias/","text":"Alias \u00b6 The alias utility shall create or redefine alias definitions or write the values of existing alias definitions to standard output. For more infomation see Alias Examples \u00b6 # Search Through Terminal History alias hs = 'history | grep' #Open file with admin access alias snano = 'sudo nano' #clear terminal screen alias c = 'clear' # Shows all open ports alias ports = 'netstat -tulanp' #Tail a file alias t = 'tail -f' References \u00b6 Man Aliases","title":"alias"},{"location":"cmds/common/alias/#alias","text":"The alias utility shall create or redefine alias definitions or write the values of existing alias definitions to standard output. For more infomation see Alias","title":"Alias"},{"location":"cmds/common/alias/#examples","text":"# Search Through Terminal History alias hs = 'history | grep' #Open file with admin access alias snano = 'sudo nano' #clear terminal screen alias c = 'clear' # Shows all open ports alias ports = 'netstat -tulanp' #Tail a file alias t = 'tail -f'","title":"Examples"},{"location":"cmds/common/alias/#references","text":"Man Aliases","title":"References"},{"location":"cmds/common/cat/","text":"cat \u00b6 Concatenate files and print on the standard output Examples \u00b6 ~/d/r/m/nix_intro> cat .gitignore .venv/ site/ Add line numbers to the output ~/d/r/m/nix_intro> cat -n requirements.txt 1 Click == 7 .0 2 Jinja2 == 2 .10 3 livereload == 2 .6.0 4 Markdown == 3 .1 5 MarkupSafe == 1 .1.1 6 mkdocs == 1 .0.4 7 mkdocs-bootstrap386 == 0 .0.1 8 mkdocs-material == 4 .1.1 9 mkdocs-rtd-dropdown == 1 .0.2 10 Pygments == 2 .3.1 11 pymdown-extensions == 6 .0 12 PyYAML == 5 .1 13 six == 1 .12.0 14 tornado == 6 .0.2 Concatenate multiple files with line numbers ~/d/r/m/nix_intro> cat -n .gitignore requirements.txt 1 .venv/ 2 site/ 3 Click == 7 .0 4 Jinja2 == 2 .10 5 livereload == 2 .6.0 6 Markdown == 3 .1 7 MarkupSafe == 1 .1.1 8 mkdocs == 1 .0.4 9 mkdocs-bootstrap386 == 0 .0.1 10 mkdocs-material == 4 .1.1 11 mkdocs-rtd-dropdown == 1 .0.2 12 Pygments == 2 .3.1 13 pymdown-extensions == 6 .0 14 PyYAML == 5 .1 15 six == 1 .12.0 16 tornado == 6 .0.2 Concatenate multiple files and send the output to a file. ~/d/r/m/nix_intro> cat -n .gitignore requirements.txt > output.txt Print all non visiable characters cat docs/shell/index.md -n References \u00b6 Man","title":"cat"},{"location":"cmds/common/cat/#cat","text":"Concatenate files and print on the standard output","title":"cat"},{"location":"cmds/common/cat/#examples","text":"~/d/r/m/nix_intro> cat .gitignore .venv/ site/ Add line numbers to the output ~/d/r/m/nix_intro> cat -n requirements.txt 1 Click == 7 .0 2 Jinja2 == 2 .10 3 livereload == 2 .6.0 4 Markdown == 3 .1 5 MarkupSafe == 1 .1.1 6 mkdocs == 1 .0.4 7 mkdocs-bootstrap386 == 0 .0.1 8 mkdocs-material == 4 .1.1 9 mkdocs-rtd-dropdown == 1 .0.2 10 Pygments == 2 .3.1 11 pymdown-extensions == 6 .0 12 PyYAML == 5 .1 13 six == 1 .12.0 14 tornado == 6 .0.2 Concatenate multiple files with line numbers ~/d/r/m/nix_intro> cat -n .gitignore requirements.txt 1 .venv/ 2 site/ 3 Click == 7 .0 4 Jinja2 == 2 .10 5 livereload == 2 .6.0 6 Markdown == 3 .1 7 MarkupSafe == 1 .1.1 8 mkdocs == 1 .0.4 9 mkdocs-bootstrap386 == 0 .0.1 10 mkdocs-material == 4 .1.1 11 mkdocs-rtd-dropdown == 1 .0.2 12 Pygments == 2 .3.1 13 pymdown-extensions == 6 .0 14 PyYAML == 5 .1 15 six == 1 .12.0 16 tornado == 6 .0.2 Concatenate multiple files and send the output to a file. ~/d/r/m/nix_intro> cat -n .gitignore requirements.txt > output.txt Print all non visiable characters cat docs/shell/index.md -n","title":"Examples"},{"location":"cmds/common/cat/#references","text":"Man","title":"References"},{"location":"cmds/common/cd/","text":"cd \u00b6 The cd command shall change the working directory of the current shell execution environment If no directory operand is given and the HOME environment variable is empty or undefined no further steps shall be taken If no directory operand is given and the HOME environment variable is set to a non-empty value,HOME environment variable will be use as directory operand. When a (-) is used as the operand, this shall be equivalent to the command: cd \" $OLDPWD \" && pwd Examples \u00b6 Goes to A dir cd /tmp Goes to last dirrectory cd - Goes to $HOME cd References \u00b6 Man","title":"cd"},{"location":"cmds/common/cd/#cd","text":"The cd command shall change the working directory of the current shell execution environment If no directory operand is given and the HOME environment variable is empty or undefined no further steps shall be taken If no directory operand is given and the HOME environment variable is set to a non-empty value,HOME environment variable will be use as directory operand. When a (-) is used as the operand, this shall be equivalent to the command: cd \" $OLDPWD \" && pwd","title":"cd"},{"location":"cmds/common/cd/#examples","text":"Goes to A dir cd /tmp Goes to last dirrectory cd - Goes to $HOME cd","title":"Examples"},{"location":"cmds/common/cd/#references","text":"Man","title":"References"},{"location":"cmds/common/chmod/","text":"chmod \u00b6 chmod changes the file mode bits of each given file according to mode, which can be either a symbolic representation of changes to make, or an octal number rep\u2010 resenting the bit pattern for the new mode bits. A combination of the letters ugoa controls which users\u2019 access to the file will be changed: the user who owns it ( u ), other users in the file\u2019s group ( g ), other users not in the file\u2019s group ( o ), or all users ( a ). If none of these are given, the effect is as if ( a ) were given, but bits that are set in the umask are not affected. The operator + causes the selected file mode bits to be added to the existing file mode bits of each file; - causes them to be removed; The letters rwxXst select file mode bits for the affected users: read ( r ), write ( w ), execute (or search for directories) ( x ), execute/search only if the file is a directory or already has execute permission for some user ( X ), set user or group ID on execution ( s ), restricted deletion flag or sticky bit ( t ). A numeric mode is from one to four octal digits (0-7), derived by adding up the bits with values 4, 2, and 1 Omitted digits are assumed to be leading zeros. The first digit selects the set user ID (4) and set group ID (2) and restricted deletion or sticky (1) attributes. The second digit selects permissions for the user who owns the file: read (4), write (2), and execute (1); the third selects permissions for other users in the file\u2019s group, with the same values; and the fourth for other users not in the file\u2019s group, with the same values. Binary Octal Perms 0 000 \u2014 1 001 \u2013x 2 010 -w- 3 011 -wx 4 100 r\u2013 5 101 rw 6 111 rwx Note chmod never changes the permissions of symbolic links This is not a problem since the permissions of symbolic links are never used Examples \u00b6 Change permissions output a diagnostic for every file processed chmod -v 0666 myFolder Change permission to multiples users and groups at the same time chmod u = rwe,g = rw,o-rwx hello.txt Change permissions and write References \u00b6 Man","title":"chmod"},{"location":"cmds/common/chmod/#chmod","text":"chmod changes the file mode bits of each given file according to mode, which can be either a symbolic representation of changes to make, or an octal number rep\u2010 resenting the bit pattern for the new mode bits. A combination of the letters ugoa controls which users\u2019 access to the file will be changed: the user who owns it ( u ), other users in the file\u2019s group ( g ), other users not in the file\u2019s group ( o ), or all users ( a ). If none of these are given, the effect is as if ( a ) were given, but bits that are set in the umask are not affected. The operator + causes the selected file mode bits to be added to the existing file mode bits of each file; - causes them to be removed; The letters rwxXst select file mode bits for the affected users: read ( r ), write ( w ), execute (or search for directories) ( x ), execute/search only if the file is a directory or already has execute permission for some user ( X ), set user or group ID on execution ( s ), restricted deletion flag or sticky bit ( t ). A numeric mode is from one to four octal digits (0-7), derived by adding up the bits with values 4, 2, and 1 Omitted digits are assumed to be leading zeros. The first digit selects the set user ID (4) and set group ID (2) and restricted deletion or sticky (1) attributes. The second digit selects permissions for the user who owns the file: read (4), write (2), and execute (1); the third selects permissions for other users in the file\u2019s group, with the same values; and the fourth for other users not in the file\u2019s group, with the same values. Binary Octal Perms 0 000 \u2014 1 001 \u2013x 2 010 -w- 3 011 -wx 4 100 r\u2013 5 101 rw 6 111 rwx Note chmod never changes the permissions of symbolic links This is not a problem since the permissions of symbolic links are never used","title":"chmod"},{"location":"cmds/common/chmod/#examples","text":"Change permissions output a diagnostic for every file processed chmod -v 0666 myFolder Change permission to multiples users and groups at the same time chmod u = rwe,g = rw,o-rwx hello.txt Change permissions and write","title":"Examples"},{"location":"cmds/common/chmod/#references","text":"Man","title":"References"},{"location":"cmds/common/clear/","text":"clear \u00b6 Clears your screen if this is possible, including its scrollback buffer clear writes to the standard output. Examples \u00b6 Clear the terminal clear Clear the terminal, do not clear scrollback clear -x References \u00b6 Man","title":"clear"},{"location":"cmds/common/clear/#clear","text":"Clears your screen if this is possible, including its scrollback buffer clear writes to the standard output.","title":"clear"},{"location":"cmds/common/clear/#examples","text":"Clear the terminal clear Clear the terminal, do not clear scrollback clear -x","title":"Examples"},{"location":"cmds/common/clear/#references","text":"Man","title":"References"},{"location":"cmds/common/cp/","text":"This is the first paragraph of the document.","title":"cp"},{"location":"cmds/common/date/","text":"This is the first paragraph of the document.","title":"date"},{"location":"cmds/common/echo/","text":"This is the first paragraph of the document.","title":"echo"},{"location":"cmds/common/grep/","text":"This is the first paragraph of the document.","title":"grep"},{"location":"cmds/common/head/","text":"This is the first paragraph of the document.","title":"head"},{"location":"cmds/common/history/","text":"This is the first paragraph of the document.","title":"history"},{"location":"cmds/common/kill/","text":"This is the first paragraph of the document.","title":"kill"},{"location":"cmds/common/killall/","text":"This is the first paragraph of the document.","title":"killall"},{"location":"cmds/common/less/","text":"This is the first paragraph of the document.","title":"less"},{"location":"cmds/common/ls/","text":"This is the first paragraph of the document.","title":"ls"},{"location":"cmds/common/man/","text":"This is the first paragraph of the document.","title":"man"},{"location":"cmds/common/mkdir/","text":"This is the first paragraph of the document.","title":"mkdir"},{"location":"cmds/common/more/","text":"This is the first paragraph of the document.","title":"more"},{"location":"cmds/common/mv/","text":"This is the first paragraph of the document.","title":"mv"},{"location":"cmds/common/pwd/","text":"This is the first paragraph of the document.","title":"pwd"},{"location":"cmds/common/rm/","text":"This is the first paragraph of the document.","title":"rm"},{"location":"cmds/common/rmdir/","text":"This is the first paragraph of the document.","title":"rmdir"},{"location":"cmds/common/tail/","text":"This is the first paragraph of the document.","title":"tail"},{"location":"cmds/common/touch/","text":"This is the first paragraph of the document.","title":"touch"},{"location":"fs/","text":"The File system \u00b6 \u201cOn a UNIX system, everything is a file; if something is not a file, it is a process.\u201d It makes no difference between a file and a directory, since a directory is just a file containing names of other files. Programs, services, texts, images, and so forth, are all files. Input and output devices, and generally all devices, are considered to be files, according to the system. The -l option of ls displays the file type, using the first character of each input line ~/d/r/m/nix_intro> ls -l total 12 drwxr-xr-x 1 cortiz cortiz 86 Mar 30 18 :11 docs/ -rw-r--r-- 1 cortiz cortiz 1590 Mar 30 11 :01 Makefile drwxr-xr-x 1 cortiz cortiz 16 Mar 30 18 :35 material-mod/ -rw-r--r-- 1 cortiz cortiz 1280 Mar 30 18 :36 mkdocs.yml -rw-r--r-- 1 cortiz cortiz 244 Mar 30 10 :51 requirements.txt drwxr-xr-x 1 cortiz cortiz 148 Mar 30 14 :51 site/ Symbol Meaning - Regular file d Directory l Link c Special file s Socket p Named pipe b Block device Permissons \u00b6 Each file and directory has three user based permission groups owner Apply only the owner of the file or directory, they will not impact the actions of other users. group Apply only to the group that has been assigned to the file or directory, they will not effect the actions of other users. all users - Apply to all other users on the system, this is the permission group that you want to watch the most. There are only 3 types of permissions: read r - User\u2019s capability to read the contents of the file. write w - User\u2019s capability to write or modify a file or directory. execute x - User\u2019s capability to execute a file or view the contents of a directory. This permissions can be view, the same way we saw the file type, by using the -l of ls ~/d/r/m/nix_intro> ls -l total 12 drwxr-xr-x 1 cortiz cortiz 86 Mar 30 18 :11 docs/ -rw-r--r-- 1 cortiz cortiz 1590 Mar 30 11 :01 Makefile drwxr-xr-x 1 cortiz cortiz 16 Mar 30 18 :35 material-mod/ -rw-r--r-- 1 cortiz cortiz 1280 Mar 30 18 :36 mkdocs.yml -rw-r--r-- 1 cortiz cortiz 244 Mar 30 10 :51 requirements.txt drwxr-xr-x 1 cortiz cortiz 148 Mar 30 14 :51 site/ Where after, the file type, the first 3, are the owners permissions, the next 3 are the group permission and finally the last 3 are the permissions for all the users. It\u2019s possible to change, permissions by using the command chmod recent version of chmod now can accept a more graphical way to change the permissions by using chars instead of bit more. chmod a+wrx file chmod g-w file2 chmod ug+x file3 The syntax looks like this. First, we specified to whom we will give permission by using * u owner * g group * o others * a all users We can define multiple affected user and groups by adding them together ug or ag for example. Then we use + or - to add or remove permissions * r for read * w for write * x for execute Like the recipient of the permissions, we can concardate the permission to give multiple at the same time. For more information about chmod check the command documentation , or it\u2019s man page man chmod","title":"Filesystem"},{"location":"fs/#the-file-system","text":"\u201cOn a UNIX system, everything is a file; if something is not a file, it is a process.\u201d It makes no difference between a file and a directory, since a directory is just a file containing names of other files. Programs, services, texts, images, and so forth, are all files. Input and output devices, and generally all devices, are considered to be files, according to the system. The -l option of ls displays the file type, using the first character of each input line ~/d/r/m/nix_intro> ls -l total 12 drwxr-xr-x 1 cortiz cortiz 86 Mar 30 18 :11 docs/ -rw-r--r-- 1 cortiz cortiz 1590 Mar 30 11 :01 Makefile drwxr-xr-x 1 cortiz cortiz 16 Mar 30 18 :35 material-mod/ -rw-r--r-- 1 cortiz cortiz 1280 Mar 30 18 :36 mkdocs.yml -rw-r--r-- 1 cortiz cortiz 244 Mar 30 10 :51 requirements.txt drwxr-xr-x 1 cortiz cortiz 148 Mar 30 14 :51 site/ Symbol Meaning - Regular file d Directory l Link c Special file s Socket p Named pipe b Block device","title":"The File system"},{"location":"fs/#permissons","text":"Each file and directory has three user based permission groups owner Apply only the owner of the file or directory, they will not impact the actions of other users. group Apply only to the group that has been assigned to the file or directory, they will not effect the actions of other users. all users - Apply to all other users on the system, this is the permission group that you want to watch the most. There are only 3 types of permissions: read r - User\u2019s capability to read the contents of the file. write w - User\u2019s capability to write or modify a file or directory. execute x - User\u2019s capability to execute a file or view the contents of a directory. This permissions can be view, the same way we saw the file type, by using the -l of ls ~/d/r/m/nix_intro> ls -l total 12 drwxr-xr-x 1 cortiz cortiz 86 Mar 30 18 :11 docs/ -rw-r--r-- 1 cortiz cortiz 1590 Mar 30 11 :01 Makefile drwxr-xr-x 1 cortiz cortiz 16 Mar 30 18 :35 material-mod/ -rw-r--r-- 1 cortiz cortiz 1280 Mar 30 18 :36 mkdocs.yml -rw-r--r-- 1 cortiz cortiz 244 Mar 30 10 :51 requirements.txt drwxr-xr-x 1 cortiz cortiz 148 Mar 30 14 :51 site/ Where after, the file type, the first 3, are the owners permissions, the next 3 are the group permission and finally the last 3 are the permissions for all the users. It\u2019s possible to change, permissions by using the command chmod recent version of chmod now can accept a more graphical way to change the permissions by using chars instead of bit more. chmod a+wrx file chmod g-w file2 chmod ug+x file3 The syntax looks like this. First, we specified to whom we will give permission by using * u owner * g group * o others * a all users We can define multiple affected user and groups by adding them together ug or ag for example. Then we use + or - to add or remove permissions * r for read * w for write * x for execute Like the recipient of the permissions, we can concardate the permission to give multiple at the same time. For more information about chmod check the command documentation , or it\u2019s man page man chmod","title":"Permissons"},{"location":"shell/","text":"The Shell \u00b6 Unix shell is a command-line interpreter or shell that provides a command line user interface for Unix-like operating systems. The shell is both an interactive command language and a scripting language, and is used by the operating system to control the execution of the system using shell scripts. Shell Operation \u00b6 The following is a brief description of the shell\u2019s operation when it reads and executes a command. Basically, the shell does the following: Reads its input from a file (see Shell Scripts ) or from the user\u2019s terminal. Breaks the input into words and operators. These tokens are separated by metacharacters. Alias expansion is performed by this step (see Alias ). Parses the tokens into simple and compound commands. Performs the various shell expansions, breaking the expanded tokens into lists of filenames and commands and arguments. Performs any necessary redirections (see Pipes and Redirections ) and removes the redirection operators and their operands from the argument list. Executes the command. Optionally waits for the command to complete and collects its exit status (see Exit Status). Variables \u00b6 As in any other programming language, the shell has variables, these variables do not have any datatype as they can store a number, a character, a string of characters or lists. All variables are global to the current shell session (but not to a sub-process) The standard practice is that variables are always in uppercase, but there is no technical reason why they can\u2019t be in lowercase. To create a variable name it, and assign a value to it MY_VAR = \"hello\" To access a variable, add the $ prefix to the name of the variable echo $MY_VAR The shell can also, expand variables within strings created by double-quotes \" echo \"The value of MY_VAR is $MY_VAR \" Using export in front of a variable makes the variable available to sub-processes. This variables, also call Environment Variables export JAVA_HOME = /opt/java Variables are always expanded before running the command (step 4, of Shell Operation) Shells like bash, zsh, and fish will run scripts on there initialization that populate variables, this scripts can for all users, and each user can define it\u2019s own (.bashrc or .bash_profile for bash, .zshrc for zsh) in user\u2019s home dirrectory. These variables will be always present in the shell session. Examples of these variables are: USER, current user name HOSTNAME, name of the machine SHELL, current shell PATH, list of directories where the shell will look up for commands. $PATH \u00b6 The $PATH variable is one of the most important variable in a shell session, since it\u2019s a list of directories where the shell will look for executables (binaries, or scripts). The shell will always use the first binary found, so a user can override this variable to change which binary will be used. This change can done to a current shell session or make it permanent by adding the override in the shell initialization script. export PATH = /my/bin/location: $PATH Pattern Matching \u00b6 Also known as globbing or glob, is a term used to describe the expansion or the match of values returned when using wildcards, regular expressions, or other pattern matches. The special pattern characters (or wildcards) have the following meanings: * Matches any string, including the null string. ? Matches any single character. [\u2026] Matches any one of the enclosed characters. A pair of characters separated by a hyphen denotes a range expression; ?(pattern-list) Matches zero or one occurrence of the given patterns. *(pattern-list) Matches zero or more occurrences of the given patterns. +(pattern-list) Matches one or more occurrences of the given patterns. @(pattern-list) Matches one of the given patterns. !(pattern-list) Matches anything except one of the given patterns. Examples: ls *.jar ls ch [ e ] * Shell Expansions \u00b6 An expansion is performed on the command line after it has been split into tokens. There are seven kinds of expansion performed: brace expansion Brace expansion is a mechanism by which arbitrary strings may be generated. echo a { d,c,b } e tilde expansion The tilde (~) may be used to refer your own home directory or other users home directory. If the tilde-prefix is a ~+, the value of the shell variable PWD replaces the tilde-prefix If the tilde-prefix is a ~-, the value of the shell variable OLDPWD, if it is set, is substituted. ls ~ cd /etc pwd cd /bin pwd echo $OLDPWD # display /etc/ directory listing and not /bin ls ~- parameter and variable expansion The \u2018$\u2019 character introduces parameter expansion, command substitution, or arithmetic expansion. string = 01234567890abcdefgh echo ${ string : 7 } echo ${ string : -7: 2 } command substitution allows the output of a command to replace the command itself. $( command ) ` command ` arithmetic expansion allows the evaluation of an arithmetic expression and the substitution of the result. $(( expression )) process substitution allows a process\u2019s input or output to be referred to using a filename. < ( list ) > ( list ) word splitting The shell scans the results of parameter expansion, command substitution, and arithmetic expansion that did not occur within double quotes for word splitting. filename expansion Alias \u00b6 An alias is a keyboard shortcut, an abbreviation to avoiding typing a long command sequence alias la = ls -alh The command-line will automatically be replaced la with ls -alh Aliases can be set by shell session or, permanent by adding them in the shell initialization script. Aliases can be named same as commands, this aliases will take priority over the actual command regardless of its position in the $PATH variable this is useful when, we want to add default arguments and options to the command, for example alias grep = 'grep --color' List of common and useful aliases. # Search Through Terminal History alias hs = 'history | grep' #Open file with admin access alias snano = 'sudo nano' #clear terminal screen alias c = 'clear' # Shows all open ports alias ports = 'netstat -tulanp' #Tail a file alias t = 'tail -f' Exit Status \u00b6 The Portable Operating System Interface (POSIX) defines that all process should have an exit code. Exit codes are a number between 0 and 255, which is returned by any Unix command when it returns control to its parent process. 0 always means that the command was run successfully, any other number, will be interpreted as an error by the shell. Most POSIX compliant shells will store the Exit code in a variable named $? ls echo $? ls IdontExist echo $? The first echo $? will return 0 , since ls run without any issue, The following echo $? will return 2 since, ls was not run successfully, since, IdontExist well, does not exists. Pipes and Redirections \u00b6 Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface. \u2014 Peter H. Salus. A Quarter-Century of Unix. Addison-Wesley. 1994. ISBN 0-201-54777-5. Commands can send and receive output from other commands using pipelines and redirections. They both do the same basic thing; they redirect a file descriptor of the process executed. Pipe is used to pass output to another program or utility. Redirect is used to pass output to either a file or stream. A pipeline is a sequence of one or more commands separated by one of the control operators \u2018|\u2019 or \u2018|&\u2019. The output of each command in the pipeline is connected via a pipe to the input of the next command. That is, each command reads the previous command\u2019s output. ls | head -3 In the example above we send the output of ls to head -3 so we only print the first 3 results of ls A pipe connects the stdout of one process to the stdin of another. Redirection allows commands\u2019 file handles to be duplicated, opened, closed, made to refer to different files, and can change the files the command reads from and writes to. At any given time there are always three default files descriptors open, stdin (the keyboard), stdout (the screen), and stderr (error messages output to the screen). The file descriptors for stdin , stdout , and stderr are 0 , 1 , and 2 , respectively. > ( > is the same as 1> ) is the simplest redirection, this will redirect all stdout to a given file. ls > results.txt This will redirect the output of ls to a file named results.txt We can also \u201cmerge\u201d two file descriptors to point to the same file, this is useful when we want to have the output of stdout and stderr in the same file. To point them to the same file descriptor we use 2>&1 ( same as &>) That means that the output of 2 ( stderr ) should be redirected to 1 ( stdout ). ls 2 > & 1 > output.txt In this sequence, we tell the shell that we want the output of stderr (2) to be redirected to stdout (1) and the second > will send the output of stdout (now merge with stderr ) to a file name output.txt Redirrections will delete any information at there destination before writing anything, to avoid that the >> redirect should be used, when used, it will append the new output at the end of the destination. It is also possible to redirect stdin of a command by using < this will read the given file descriptor and send it to the command stdin . cat < myFile.txt By default cat will listen to stdin until the EOF character (ctrl-d) is sent. In the past example, change stdin to be a file. Lists of Commands \u00b6 It\u2019s possible to run multiple commands as a single line making a list of commands to be run, the list is made by using ; between the commands that we want to run. command1 ; command2 ; command 3 | command3.1 > myoutput.txt ; command 4 It\u2019s also possible to run the next command depending on the exit value by using && (AND) or || (OR) command1 && command2 command2 is executed if, and only if, command1 returns an exits status of zero (success). command1 || command2 command2 is executed if, and only if, command1 returns a non-zero exit status. The return status of AND and OR lists is the exit status of the last command executed in the list \u2018&&\u2019 and \u2018||\u2019 have equal precedence, followed by \u2018;\u2019 and \u2018&\u2019, which have equal precedence Shell Scripts \u00b6 Shells can also read a file, and execute the commands within the file this file is commonly known as shell scripts. Each shell can have its own syntax for these files, but in this guide, we will use the most common syntax, the sh which is also compatible with zsh shell. It\u2019s common to add #! as the first line of the scripts, this tells the shell which interpreter should be used to execute the script. #! is also known as shebang and its always followed by the full path of the interpreter that will run the script. #!/usr/bin/bash echo \"Hello World\" This will make our file to be interpreted by bash, it\u2019s also possible to use other interpreters like python, ruby, nodejs and since Java 10, Java. #!/usr/bin/python3 print ( \"Hello World\" ) #!/usr/bin/env node const http = require ( 'http' ) ; const hostname = '127.0.0.1' ; const port = 3000 ; const server = http.createServer (( req, res ) = > { res.statusCode = 200 ; res.setHeader ( 'Content-Type' , 'text/plain' ) ; res.end ( 'Hello World\\n' ) ; }) ; server.listen ( port, hostname, () = > { console.log ( ` Server running at http:// ${ hostname } : ${ port } / ` ) ; }) ; It is possible to the a script to use a specific version of a interpreter like the python example, or let the environment decided (node js example) which interpreter will be used (usualy, its the first found in the $PATH variable), the latter is the best practice. Conditionals \u00b6 If,else & If else \u00b6 The test-commands list is executed, and if its return status is zero, the consequent-commands list is executed. If if [ test-commands ] ; then <commands> fi If else if [ test-commands ] then <commands> else <other commands> fi If else if else if [ test-commands ] then <commands> elif [ test-commands ] then <different commands> else <other commands> fi Test Expressions ! EXPRESSION The EXPRESSION is false. -n STRING The length of STRING is greater than zero. -z STRING The lengh of STRING is zero (ie it is empty). STRING1 = STRING2 STRING1 is equal to STRING2 STRING1 != STRING2 STRING1 is not equal to STRING2 INTEGER1 -eq INTEGER2 INTEGER1 is numerically equal to INTEGER2 INTEGER1 -gt INTEGER2 INTEGER1 is numerically greater than INTEGER2 INTEGER1 -lt INTEGER2 INTEGER1 is numerically less than INTEGER2 INTEGER1 -ge INTEGER2 INTEGER1 is numerically greater or equal than INTEGER2 INTEGER1 -le INTEGER2 INTEGER1 is numerically less or equal than INTEGER2 -d FILE FILE exists and is a directory. -e FILE FILE exists. -r FILE FILE exists and the read permission is granted. -s FILE FILE exists and it\u2019s size is greater than zero (ie. it is not empty). -w FILE FILE exists and the write permission is granted. -x FILE FILE exists and the execute permission is granted. Examples \u00b6 if [ $value -eq 1 ] then echo \"has value\" fi my_file = \"myfile.txt\" if [ -s $my_file ] then cat $my_file else echo \"File not found\" fi my_var = 2 if [ $my_var -gt 0 ] then echo \"More than 2\" elif [ $my_var -lt 0 ] then echo \"it's negative\" else echo \"it's zero\" fi Case \u00b6 case will selectively execute the command-list corresponding to the first pattern that matches the word. case <variable> in <pattern 1 > ) commands ;; <pattern 2 > ) other_command ;; * ) defautl_command ;; esac case $action in start ) echo starting ;; stop ) echo stoping ;; restart ) echo restarting ;; * ) echo don \\' t know ;; esac Loops \u00b6 until Execute consequent-commands as long as test-commands has an exit status which is not zero. until test-commands ; do consequent-commands ; done count = 1 until [ $count -gt 5 ] do printf \"Count has a value of $count \\n\" (( count++ )) done while Execute consequent-commands as long as test-commands has an exit status of zero. while test-commands ; do consequent-commands ; don i = \"0\" while [ $i -lt 4 ] do echo \" $i \" i = $ [ $i +1 ] done for Expand words (see Shell Expansions), and execute commands once for each member in the resultant list, with name bound to the current member (as internal loop variable $name) for name [ [ in [ words \u2026 ] ] ; ] do commands ; done for (( expr1 ; expr2 ; expr3 )) ; do commands ; done for file in $( ls ) ; do echo \"File is $file \" ; done Functions \u00b6 A function is essentially a set of commands that can be called numerous times. The purpose of a function is to help you make your bash scripts more readable and to avoid writing the same code over and over again. function_name () { commands } function function_name { commands } Variables can also have, the same name as commands, like an alias, this will always take precedence over the actual command. Since all shell scripts are interpreted, functions must be declared, before using them. Variables Scope \u00b6 Global variables are variables that can be accessed from anywhere in the script regardless of the scope. All variables by default are defined as global, even if declared inside the function. Local variables can be declared within the function body with the local and keyword and can be used only inside that function. #!/bin/bash var1 = 'A' var2 = 'B' my_function () { local var1 = 'C' var2 = 'D' echo \"Inside function: var1: $var1 , var2: $var2 \" } echo \"Before executing function: var1: $var1 , var2: $var2 \" my_function echo \"After executing function: var1: $var1 , var2: $var2 \" Return Values \u00b6 When a function completes, its return value is the status of the last statement executed in the function my_function () { echo \"some result\" return 55 } my_function echo $? Arguments \u00b6 To pass any number of arguments to the bash function simply put them right after the function\u2019s name It is a best practice to double quote the arguments *The passed parameters are $1 , $2 , $3 \u2026 $n , corresponding to the position of the parameter after the function\u2019s name., The $0 variable is reserved for the function\u2019s name. The `$# variable holds the number of positional parameters/arguments passed to the function. The $* or $@ variable holds all positional parameters/arguments passed to the function. greeting () { echo \"Hello $1 \" } greeting \"Joe\"","title":"Shell"},{"location":"shell/#the-shell","text":"Unix shell is a command-line interpreter or shell that provides a command line user interface for Unix-like operating systems. The shell is both an interactive command language and a scripting language, and is used by the operating system to control the execution of the system using shell scripts.","title":"The Shell"},{"location":"shell/#shell-operation","text":"The following is a brief description of the shell\u2019s operation when it reads and executes a command. Basically, the shell does the following: Reads its input from a file (see Shell Scripts ) or from the user\u2019s terminal. Breaks the input into words and operators. These tokens are separated by metacharacters. Alias expansion is performed by this step (see Alias ). Parses the tokens into simple and compound commands. Performs the various shell expansions, breaking the expanded tokens into lists of filenames and commands and arguments. Performs any necessary redirections (see Pipes and Redirections ) and removes the redirection operators and their operands from the argument list. Executes the command. Optionally waits for the command to complete and collects its exit status (see Exit Status).","title":"Shell Operation"},{"location":"shell/#variables","text":"As in any other programming language, the shell has variables, these variables do not have any datatype as they can store a number, a character, a string of characters or lists. All variables are global to the current shell session (but not to a sub-process) The standard practice is that variables are always in uppercase, but there is no technical reason why they can\u2019t be in lowercase. To create a variable name it, and assign a value to it MY_VAR = \"hello\" To access a variable, add the $ prefix to the name of the variable echo $MY_VAR The shell can also, expand variables within strings created by double-quotes \" echo \"The value of MY_VAR is $MY_VAR \" Using export in front of a variable makes the variable available to sub-processes. This variables, also call Environment Variables export JAVA_HOME = /opt/java Variables are always expanded before running the command (step 4, of Shell Operation) Shells like bash, zsh, and fish will run scripts on there initialization that populate variables, this scripts can for all users, and each user can define it\u2019s own (.bashrc or .bash_profile for bash, .zshrc for zsh) in user\u2019s home dirrectory. These variables will be always present in the shell session. Examples of these variables are: USER, current user name HOSTNAME, name of the machine SHELL, current shell PATH, list of directories where the shell will look up for commands.","title":"Variables"},{"location":"shell/#path","text":"The $PATH variable is one of the most important variable in a shell session, since it\u2019s a list of directories where the shell will look for executables (binaries, or scripts). The shell will always use the first binary found, so a user can override this variable to change which binary will be used. This change can done to a current shell session or make it permanent by adding the override in the shell initialization script. export PATH = /my/bin/location: $PATH","title":"$PATH"},{"location":"shell/#pattern-matching","text":"Also known as globbing or glob, is a term used to describe the expansion or the match of values returned when using wildcards, regular expressions, or other pattern matches. The special pattern characters (or wildcards) have the following meanings: * Matches any string, including the null string. ? Matches any single character. [\u2026] Matches any one of the enclosed characters. A pair of characters separated by a hyphen denotes a range expression; ?(pattern-list) Matches zero or one occurrence of the given patterns. *(pattern-list) Matches zero or more occurrences of the given patterns. +(pattern-list) Matches one or more occurrences of the given patterns. @(pattern-list) Matches one of the given patterns. !(pattern-list) Matches anything except one of the given patterns. Examples: ls *.jar ls ch [ e ] *","title":"Pattern Matching"},{"location":"shell/#shell-expansions","text":"An expansion is performed on the command line after it has been split into tokens. There are seven kinds of expansion performed: brace expansion Brace expansion is a mechanism by which arbitrary strings may be generated. echo a { d,c,b } e tilde expansion The tilde (~) may be used to refer your own home directory or other users home directory. If the tilde-prefix is a ~+, the value of the shell variable PWD replaces the tilde-prefix If the tilde-prefix is a ~-, the value of the shell variable OLDPWD, if it is set, is substituted. ls ~ cd /etc pwd cd /bin pwd echo $OLDPWD # display /etc/ directory listing and not /bin ls ~- parameter and variable expansion The \u2018$\u2019 character introduces parameter expansion, command substitution, or arithmetic expansion. string = 01234567890abcdefgh echo ${ string : 7 } echo ${ string : -7: 2 } command substitution allows the output of a command to replace the command itself. $( command ) ` command ` arithmetic expansion allows the evaluation of an arithmetic expression and the substitution of the result. $(( expression )) process substitution allows a process\u2019s input or output to be referred to using a filename. < ( list ) > ( list ) word splitting The shell scans the results of parameter expansion, command substitution, and arithmetic expansion that did not occur within double quotes for word splitting. filename expansion","title":"Shell Expansions"},{"location":"shell/#alias","text":"An alias is a keyboard shortcut, an abbreviation to avoiding typing a long command sequence alias la = ls -alh The command-line will automatically be replaced la with ls -alh Aliases can be set by shell session or, permanent by adding them in the shell initialization script. Aliases can be named same as commands, this aliases will take priority over the actual command regardless of its position in the $PATH variable this is useful when, we want to add default arguments and options to the command, for example alias grep = 'grep --color' List of common and useful aliases. # Search Through Terminal History alias hs = 'history | grep' #Open file with admin access alias snano = 'sudo nano' #clear terminal screen alias c = 'clear' # Shows all open ports alias ports = 'netstat -tulanp' #Tail a file alias t = 'tail -f'","title":"Alias"},{"location":"shell/#exit-status","text":"The Portable Operating System Interface (POSIX) defines that all process should have an exit code. Exit codes are a number between 0 and 255, which is returned by any Unix command when it returns control to its parent process. 0 always means that the command was run successfully, any other number, will be interpreted as an error by the shell. Most POSIX compliant shells will store the Exit code in a variable named $? ls echo $? ls IdontExist echo $? The first echo $? will return 0 , since ls run without any issue, The following echo $? will return 2 since, ls was not run successfully, since, IdontExist well, does not exists.","title":"Exit Status"},{"location":"shell/#pipes-and-redirections","text":"Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface. \u2014 Peter H. Salus. A Quarter-Century of Unix. Addison-Wesley. 1994. ISBN 0-201-54777-5. Commands can send and receive output from other commands using pipelines and redirections. They both do the same basic thing; they redirect a file descriptor of the process executed. Pipe is used to pass output to another program or utility. Redirect is used to pass output to either a file or stream. A pipeline is a sequence of one or more commands separated by one of the control operators \u2018|\u2019 or \u2018|&\u2019. The output of each command in the pipeline is connected via a pipe to the input of the next command. That is, each command reads the previous command\u2019s output. ls | head -3 In the example above we send the output of ls to head -3 so we only print the first 3 results of ls A pipe connects the stdout of one process to the stdin of another. Redirection allows commands\u2019 file handles to be duplicated, opened, closed, made to refer to different files, and can change the files the command reads from and writes to. At any given time there are always three default files descriptors open, stdin (the keyboard), stdout (the screen), and stderr (error messages output to the screen). The file descriptors for stdin , stdout , and stderr are 0 , 1 , and 2 , respectively. > ( > is the same as 1> ) is the simplest redirection, this will redirect all stdout to a given file. ls > results.txt This will redirect the output of ls to a file named results.txt We can also \u201cmerge\u201d two file descriptors to point to the same file, this is useful when we want to have the output of stdout and stderr in the same file. To point them to the same file descriptor we use 2>&1 ( same as &>) That means that the output of 2 ( stderr ) should be redirected to 1 ( stdout ). ls 2 > & 1 > output.txt In this sequence, we tell the shell that we want the output of stderr (2) to be redirected to stdout (1) and the second > will send the output of stdout (now merge with stderr ) to a file name output.txt Redirrections will delete any information at there destination before writing anything, to avoid that the >> redirect should be used, when used, it will append the new output at the end of the destination. It is also possible to redirect stdin of a command by using < this will read the given file descriptor and send it to the command stdin . cat < myFile.txt By default cat will listen to stdin until the EOF character (ctrl-d) is sent. In the past example, change stdin to be a file.","title":"Pipes and Redirections"},{"location":"shell/#lists-of-commands","text":"It\u2019s possible to run multiple commands as a single line making a list of commands to be run, the list is made by using ; between the commands that we want to run. command1 ; command2 ; command 3 | command3.1 > myoutput.txt ; command 4 It\u2019s also possible to run the next command depending on the exit value by using && (AND) or || (OR) command1 && command2 command2 is executed if, and only if, command1 returns an exits status of zero (success). command1 || command2 command2 is executed if, and only if, command1 returns a non-zero exit status. The return status of AND and OR lists is the exit status of the last command executed in the list \u2018&&\u2019 and \u2018||\u2019 have equal precedence, followed by \u2018;\u2019 and \u2018&\u2019, which have equal precedence","title":"Lists of Commands"},{"location":"shell/#shell-scripts","text":"Shells can also read a file, and execute the commands within the file this file is commonly known as shell scripts. Each shell can have its own syntax for these files, but in this guide, we will use the most common syntax, the sh which is also compatible with zsh shell. It\u2019s common to add #! as the first line of the scripts, this tells the shell which interpreter should be used to execute the script. #! is also known as shebang and its always followed by the full path of the interpreter that will run the script. #!/usr/bin/bash echo \"Hello World\" This will make our file to be interpreted by bash, it\u2019s also possible to use other interpreters like python, ruby, nodejs and since Java 10, Java. #!/usr/bin/python3 print ( \"Hello World\" ) #!/usr/bin/env node const http = require ( 'http' ) ; const hostname = '127.0.0.1' ; const port = 3000 ; const server = http.createServer (( req, res ) = > { res.statusCode = 200 ; res.setHeader ( 'Content-Type' , 'text/plain' ) ; res.end ( 'Hello World\\n' ) ; }) ; server.listen ( port, hostname, () = > { console.log ( ` Server running at http:// ${ hostname } : ${ port } / ` ) ; }) ; It is possible to the a script to use a specific version of a interpreter like the python example, or let the environment decided (node js example) which interpreter will be used (usualy, its the first found in the $PATH variable), the latter is the best practice.","title":"Shell Scripts"},{"location":"shell/#conditionals","text":"","title":"Conditionals"},{"location":"shell/#ifelse-if-else","text":"The test-commands list is executed, and if its return status is zero, the consequent-commands list is executed. If if [ test-commands ] ; then <commands> fi If else if [ test-commands ] then <commands> else <other commands> fi If else if else if [ test-commands ] then <commands> elif [ test-commands ] then <different commands> else <other commands> fi Test Expressions ! EXPRESSION The EXPRESSION is false. -n STRING The length of STRING is greater than zero. -z STRING The lengh of STRING is zero (ie it is empty). STRING1 = STRING2 STRING1 is equal to STRING2 STRING1 != STRING2 STRING1 is not equal to STRING2 INTEGER1 -eq INTEGER2 INTEGER1 is numerically equal to INTEGER2 INTEGER1 -gt INTEGER2 INTEGER1 is numerically greater than INTEGER2 INTEGER1 -lt INTEGER2 INTEGER1 is numerically less than INTEGER2 INTEGER1 -ge INTEGER2 INTEGER1 is numerically greater or equal than INTEGER2 INTEGER1 -le INTEGER2 INTEGER1 is numerically less or equal than INTEGER2 -d FILE FILE exists and is a directory. -e FILE FILE exists. -r FILE FILE exists and the read permission is granted. -s FILE FILE exists and it\u2019s size is greater than zero (ie. it is not empty). -w FILE FILE exists and the write permission is granted. -x FILE FILE exists and the execute permission is granted.","title":"If,else &amp; If else"},{"location":"shell/#examples","text":"if [ $value -eq 1 ] then echo \"has value\" fi my_file = \"myfile.txt\" if [ -s $my_file ] then cat $my_file else echo \"File not found\" fi my_var = 2 if [ $my_var -gt 0 ] then echo \"More than 2\" elif [ $my_var -lt 0 ] then echo \"it's negative\" else echo \"it's zero\" fi","title":"Examples"},{"location":"shell/#case","text":"case will selectively execute the command-list corresponding to the first pattern that matches the word. case <variable> in <pattern 1 > ) commands ;; <pattern 2 > ) other_command ;; * ) defautl_command ;; esac case $action in start ) echo starting ;; stop ) echo stoping ;; restart ) echo restarting ;; * ) echo don \\' t know ;; esac","title":"Case"},{"location":"shell/#loops","text":"until Execute consequent-commands as long as test-commands has an exit status which is not zero. until test-commands ; do consequent-commands ; done count = 1 until [ $count -gt 5 ] do printf \"Count has a value of $count \\n\" (( count++ )) done while Execute consequent-commands as long as test-commands has an exit status of zero. while test-commands ; do consequent-commands ; don i = \"0\" while [ $i -lt 4 ] do echo \" $i \" i = $ [ $i +1 ] done for Expand words (see Shell Expansions), and execute commands once for each member in the resultant list, with name bound to the current member (as internal loop variable $name) for name [ [ in [ words \u2026 ] ] ; ] do commands ; done for (( expr1 ; expr2 ; expr3 )) ; do commands ; done for file in $( ls ) ; do echo \"File is $file \" ; done","title":"Loops"},{"location":"shell/#functions","text":"A function is essentially a set of commands that can be called numerous times. The purpose of a function is to help you make your bash scripts more readable and to avoid writing the same code over and over again. function_name () { commands } function function_name { commands } Variables can also have, the same name as commands, like an alias, this will always take precedence over the actual command. Since all shell scripts are interpreted, functions must be declared, before using them.","title":"Functions"},{"location":"shell/#variables-scope","text":"Global variables are variables that can be accessed from anywhere in the script regardless of the scope. All variables by default are defined as global, even if declared inside the function. Local variables can be declared within the function body with the local and keyword and can be used only inside that function. #!/bin/bash var1 = 'A' var2 = 'B' my_function () { local var1 = 'C' var2 = 'D' echo \"Inside function: var1: $var1 , var2: $var2 \" } echo \"Before executing function: var1: $var1 , var2: $var2 \" my_function echo \"After executing function: var1: $var1 , var2: $var2 \"","title":"Variables Scope"},{"location":"shell/#return-values","text":"When a function completes, its return value is the status of the last statement executed in the function my_function () { echo \"some result\" return 55 } my_function echo $?","title":"Return Values"},{"location":"shell/#arguments","text":"To pass any number of arguments to the bash function simply put them right after the function\u2019s name It is a best practice to double quote the arguments *The passed parameters are $1 , $2 , $3 \u2026 $n , corresponding to the position of the parameter after the function\u2019s name., The $0 variable is reserved for the function\u2019s name. The `$# variable holds the number of positional parameters/arguments passed to the function. The $* or $@ variable holds all positional parameters/arguments passed to the function. greeting () { echo \"Hello $1 \" } greeting \"Joe\"","title":"Arguments"}]}